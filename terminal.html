<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CREATOR Console</title>
    <!-- Xterm.js Imports -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --primary-color: #007acc;
            --panel-bg: #252526;
            --border-color: #333;
            --red-color: #f44747;
            --green-color: #4ec9b0;
            --orange-color: #ce9178;
            --info-color: #9cdcfe;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 1em;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        h1, h2, h3, h4 {
            margin-top: 0;
            margin-bottom: 0; 
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
            font-weight: 400;
            flex-shrink: 0;
        }
        h3, h4 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0.5em;
        }
        .container {
            display: flex;
            flex-grow: 1;
            gap: 1em;
            min-height: 0;
        }
        .panel {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1em;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            gap: 1em;
            min-width: 0;
        }
        .scrollable-content {
            flex-grow: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        /* MODIFIED: Changed panel sizing from fixed to flexible */
        #visuals-panel {
            flex: 2;
            min-width: 400px;
        }
        #interaction-panel {
            flex: 3;
            min-width: 400px;
        }

        .control-group {
            margin-bottom: 1.5em;
        }
        label {
            display: block;
            margin-bottom: 0.5em;
        }
        .file-info {
            font-style: italic;
            font-size: 0.9em;
            color: var(--info-color);
            margin-left: 0.5em;
        }
        input[type="file"] {
            display: block;
            margin-bottom: 1em;
        }
        input[type="text"] {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.4em;
            border-radius: 4px;
            width: calc(100% - 1em);
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.6em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 0.5em;
            margin-bottom: 0.5em;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #005a9e;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .output-view {
            font-family: "SF Mono", "Consolas", "Courier New", monospace;
            white-space: pre;
            background-color: var(--bg-color);
            padding: 0.5em;
            border-radius: 4px;
            overflow: auto;
        }
        
        #instruction-log {
           flex-grow: 1;
           max-height: 50vh;
           min-height: 100px;
           overflow-y: auto;
        }
        
        #breakpoint-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-family: "SF Mono", "Consolas", "Courier New", monospace;
            max-height: 150px;
            overflow-y: auto;
        }
        #breakpoint-list li {
            display: flex;
            align-items: center;
            gap: 0.75em;
            padding: 0.3em;
            border-bottom: 1px solid var(--border-color);
        }
        #breakpoint-list li > span { flex-grow: 1; }
        #breakpoint-list li:last-child { border-bottom: none; }
        .bp-toggle { margin: 0; cursor: pointer; }
        .remove-bp-btn {
            background: none; border: 1px solid var(--red-color); color: var(--red-color);
            cursor: pointer; border-radius: 50%; width: 20px; height: 20px;
            line-height: 16px; padding: 0; font-weight: bold; flex-shrink: 0;
        }

        .output-section {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .output-section-grow {
            flex-grow: 1;
        }

        /* NEW: Styles for the terminal container */
        #terminal-container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            background-color: #000;
            border-radius: 4px;
            padding: 0.5em;
            box-sizing: border-box;
        }

        #footer-bar {
            flex-shrink: 0;
            background-color: var(--primary-color);
            color: white;
            padding: 0.2em 1em;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #status-line { font-weight: bold; }
    </style>
</head>
<body>

    <div class="container">
        
        <div id="visuals-panel" class="panel">
            <div class="output-section output-section-grow">
                <h3>Console Output</h3>
                <div id="terminal-container">
                    <div id="terminal" style="height: 100%; width: 100%;"></div>
                </div>
            </div>

            <div class="output-section">
                <h3>Registers</h3>
                <pre id="register-view" class="output-view">Registers will be shown here after loading...</pre>
            </div>
        </div>

        <div id="interaction-panel" class="panel">
            <div id="controls-section" class="output-section">
                <div class="scrollable-content">
                    <div class="control-group">
                        <label for="archFile">1. Load Architecture (YAML):<span id="arch-file-info" class="file-info"></span></label>
                        <input type="file" id="archFile" accept=".yml,.yaml">
                        <label for="binFile">2. Load Binary (ROM):<span id="bin-file-info" class="file-info"></span></label>
                        <input type="file" id="binFile">
                        <button id="loadBtn" disabled>Load & Reset</button>
                        <button id="clearSessionBtn" style="background-color: #a04444;" title="Clear saved architecture and ROM from browser memory">Clear Session</button>
                    </div>

                    <div class="control-group">
                        <h3>Execution</h3>
                        <button id="runBtn" disabled>Run</button>
                        <button id="pauseBtn" disabled>Pause</button>
                        <button id="stepBtn" disabled>Step</button>
                        <button id="stepOverBtn" disabled>Step Over</button>
                    </div>
                    
                    <div class="control-group">
                        <h3>Debugging</h3>
                        <label for="breakpoint-address">Breakpoint Address (Hex):</label>
                        <input type="text" id="breakpoint-address" placeholder="e.g., 0100">
                        <button id="add-breakpoint-btn" style="margin-top: 0.5em;">Add</button>
                        <h4 style="margin-top: 1em; margin-bottom: 0.5em;">Active Breakpoints</h4>
                        <ul id="breakpoint-list"></ul>
                    </div>
                </div>
            </div>
            
            <div class="output-section output-section-grow">
                <h3>Executed Instructions</h3>
                <pre id="instruction-log" class="output-view">Executed instructions will appear here...</pre>
            </div>
        </div>
    </div>
    <footer id="footer-bar">
        <span id="footer-status-line" class="pending">Waiting for files...</span>
        <span>Total Instructions: <b id="footer-total-instructions">0</b></span>
    </footer>

<script type="module">
    document.addEventListener('DOMContentLoaded', () => {

        Promise.all([
            import("./src/core/core.mjs"),
            import("./src/core/executor/executor.mjs"),
            import("./src/core/utils/creator_logger.mjs"),
            import("./src/core/capi/arch/z80.mjs")
        ]).then(([creator, executor, creator_logger, z80]) => {
            creator.initCAPI();
            window.creator = creator; // Expose to debug console
            setupEmulator(creator, executor.step, creator_logger.logger, z80);
        }).catch(error => {
            console.error("Failed to load a required emulator module:", error);
            updateStatus(`Error: Failed to load core module. Check browser console (F12) for 404 errors.`, 'error');
        });

        const footerStatusLine = document.getElementById('footer-status-line');
        function updateStatus(message, type = 'pending') {
            footerStatusLine.textContent = message;
            const footer = document.getElementById('footer-bar');
            footer.style.backgroundColor = `var(--${type}-color, var(--primary-color))`;
        }
        
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function setupEmulator(creator, step, logger, z80) {
            
            // --- DOM Elements ---
            const archFileInput = document.getElementById('archFile');
            const binFileInput = document.getElementById('binFile');
            const loadBtn = document.getElementById('loadBtn');
            const runBtn = document.getElementById('runBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const stepBtn = document.getElementById('stepBtn');
            const stepOverBtn = document.getElementById('stepOverBtn');
            const footerTotalInstructionsEl = document.getElementById('footer-total-instructions');
            const registerView = document.getElementById('register-view');
            const instructionLog = document.getElementById('instruction-log');
            const clearSessionBtn = document.getElementById('clearSessionBtn');
            const archFileInfo = document.getElementById('arch-file-info');
            const binFileInfo = document.getElementById('bin-file-info');
            const breakpointAddressInput = document.getElementById('breakpoint-address');
            const addBreakpointBtn = document.getElementById('add-breakpoint-btn');
            const breakpointList = document.getElementById('breakpoint-list');

            // --- Xterm.js Console Setup ---
            const term = new Terminal({
                convertEol: true,
                cursorBlink: true,
                theme: { background: '#000', foreground: '#d4d4d4' }
            });
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => fitAddon.fit());
            term.writeln('CREATOR Console Initialized.');
            term.writeln('I/O writes to port 0x02 will appear here.');

            // --- I/O Handler Override ---
            z80.Z80.write = (port, value) => {
                const portNum = Number(port);
                if (portNum === 0x02) { // Screen/Console Port
                    term.write(String.fromCharCode(Number(value)));
                } else {
                    console.log(`I/O Write to unhandled port 0x${portNum.toString(16)}: ${value}`);
                }
            };
            
            // --- Emulator State ---
            let isRunning = false;
            let isLoaded = false;
            let isHalted = false;
            let isPausedAtBreakpoint = false;
            let totalInstructions = 0;
            let emulationLoopHandle = null;
            const MAX_LOG_LINES = 1000;
            let logBuffer = [];
            let cachedArchContent = null;
            let cachedRomBytes = null;
            let breakpoints = new Map();

            // --- Core Functions ---
            function readFile(fileInput, readAs = 'text') {
                return new Promise((resolve, reject) => {
                    const file = fileInput.files[0];
                    if (!file) { return reject(new Error("No file selected.")); }
                    const reader = new FileReader();
                    reader.onload = (e) => resolve({ content: e.target.result, name: file.name });
                    reader.onerror = (e) => reject(new Error("Error reading file: " + e.target.error));
                    if (readAs === 'text') reader.readAsText(file);
                    else if (readAs === 'arrayBuffer') reader.readAsArrayBuffer(file);
                    else reject(new Error("Unsupported read format."));
                });
            }

            function logInstruction(pc, instrData) {
                const line = `${totalInstructions.toString().padStart(8, ' ')}: ${pc.toString(16).padStart(4, "0").toUpperCase()}  ${instrData.asm.padEnd(25)} | ${instrData.machineCode}`;
                logBuffer.push(line);
                if (logBuffer.length > MAX_LOG_LINES) logBuffer.shift();
            }

            function updateInstructionLogUI() {
                instructionLog.textContent = logBuffer.join('\n');
                instructionLog.scrollTop = instructionLog.scrollHeight;
            }

            function updateRegisterView() {
                try {
                    const registers = creator.getRegistersByBank("int_registers").elements;
                    let regText = '';
                    registers.forEach((reg, index) => {
                        const name = reg.name[0].padEnd(4, ' ');
                        const value = `0x${reg.value.toString(16).padStart(4, "0").toUpperCase()}`;
                        regText += `${name}${value}${(index + 1) % 4 === 0 ? '\n' : '\t'}`;
                    });
                    registerView.textContent = regText;
                } catch(e) {
                    registerView.textContent = "Could not read registers. Is an architecture loaded?";
                }
            }

            // --- Core Emulator Control Functions ---
            function resetUI() {
                instructionLog.textContent = '';
                logBuffer = [];
                totalInstructions = 0;
                footerTotalInstructionsEl.textContent = '0';
                isHalted = false;
                isLoaded = false;
                isPausedAtBreakpoint = false;
                runBtn.disabled = true;
                pauseBtn.disabled = true;
                stepBtn.disabled = true;
                stepOverBtn.disabled = true;
                breakpoints.clear();
                updateBreakpointListUI();
                updateStatus('Waiting for files...', 'pending');
                updateRegisterView();
                term.clear();
            }
            
            function pauseEmulation(message, type = 'pending', { atBreakpoint = false } = {}) {
                isRunning = false;
                isPausedAtBreakpoint = atBreakpoint;
                if (emulationLoopHandle) {
                    clearTimeout(emulationLoopHandle);
                    emulationLoopHandle = null;
                }
                
                runBtn.disabled = false;
                stepBtn.disabled = isPausedAtBreakpoint;
                stepOverBtn.disabled = !isPausedAtBreakpoint;
                loadBtn.disabled = false;
                pauseBtn.disabled = true;
                updateStatus(message, type);
                updateInstructionLogUI(); 
                updateRegisterView();   
            }

            function haltEmulation(finalMessage, type) {
                isRunning = false;
                isHalted = true;
                if (emulationLoopHandle) clearTimeout(emulationLoopHandle);
                emulationLoopHandle = null;
                runBtn.disabled = true;
                pauseBtn.disabled = true;
                stepBtn.disabled = true;
                stepOverBtn.disabled = true;
                updateStatus(finalMessage, type);
                updateInstructionLogUI();
                updateRegisterView();
            }

            function executeSingleInstruction() {
                try {
                    const pc_value = creator.getRegisterInfo("PC").value;
                    const ret = step();
                    if (ret.error === 1) {
                        haltEmulation(`Runtime Error: ${ret.msg}`, 'error');
                        return false;
                    }
                    totalInstructions++;
                    footerTotalInstructionsEl.textContent = totalInstructions;
                    logInstruction(pc_value, ret.instructionData);
                    if (creator.status.execution_index === -2) {
                        haltEmulation('Execution Halted (HALT instruction).', 'ok');
                    }
                    return true;
                } catch (error) {
                    console.error("Emulation step error:", error);
                    haltEmulation(`Emulation Error: ${error.message}`, 'error');
                    return false;
                }
            }
            
            function singleStep() {
                if (isHalted) return;
                try {
                    const pc_value = creator.getRegisterInfo("PC").value;
                    const bp = breakpoints.get(Number(pc_value));
                    if (bp && bp.enabled) {
                        pauseEmulation(`Breakpoint hit at 0x${pc_value.toString(16).toUpperCase()}`, 'pending', { atBreakpoint: true });
                        return;
                    }
                    executeSingleInstruction();
                } catch (error) {
                    console.error("Emulation step error:", error);
                    haltEmulation(`Emulation Error: ${error.message}`, 'error');
                }
            }

            let lastLogUpdateTime = 0;
            const LOG_UPDATE_INTERVAL = 50;

            function runEmulationCycle() {
                if (!isRunning || isHalted) return;
                const cycleStartTime = performance.now();
                while(performance.now() - cycleStartTime < 16) {
                    for (let i = 0; i < 50; i++) {
                         if (!isRunning || isHalted) break;
                         singleStep();
                    }
                    if (!isRunning || isHalted) break;
                }
                const currentTime = performance.now();
                if (currentTime - lastLogUpdateTime > LOG_UPDATE_INTERVAL) {
                    updateInstructionLogUI();
                    lastLogUpdateTime = currentTime;
                }
                if (isRunning && !isHalted) emulationLoopHandle = setTimeout(runEmulationCycle, 0);
            }
            
            // --- Event Listeners ---
            function checkFilesAndEnableLoadButton() {
                cachedArchContent = null;
                cachedRomBytes = null;
                archFileInfo.textContent = '';
                binFileInfo.textContent = '';
                if (archFileInput.files.length > 0 && binFileInput.files.length > 0) {
                    loadBtn.disabled = false;
                    updateStatus('Files selected. Ready to load.', 'pending');
                } else {
                    loadBtn.disabled = true;
                }
                if (isLoaded) {
                    resetUI();
                    updateStatus('New files selected. Please Load & Reset.', 'pending');
                }
            }
            archFileInput.addEventListener('change', checkFilesAndEnableLoadButton);
            binFileInput.addEventListener('change', checkFilesAndEnableLoadButton);

            loadBtn.addEventListener('click', async () => {
                resetUI();
                updateStatus('Loading...', 'pending');
                try {
                    let arch, rom;
                    if (cachedArchContent && cachedRomBytes) {
                        arch = { content: cachedArchContent, name: localStorage.getItem('savedArchFilename') };
                        rom = { content: cachedRomBytes, name: localStorage.getItem('savedRomFilename') };
                        updateStatus('Loading from saved session...', 'pending');
                    } else {
                        arch = await readFile(archFileInput, 'text');
                        rom = await readFile(binFileInput, 'arrayBuffer');
                    }
                    const archRet = creator.newArchitectureLoad(arch.content);
                    if (archRet.status !== "ok") throw new Error(`Architecture Error: ${archRet.token}.`);
                    creator.reset();
                    creator.main_memory.loadROM(new Uint8Array(rom.content), 0n);
                    localStorage.setItem('savedArchContent', arch.content);
                    localStorage.setItem('savedArchFilename', arch.name);
                    localStorage.setItem('savedRomContentBase64', arrayBufferToBase64(rom.content));
                    localStorage.setItem('savedRomFilename', rom.name);
                    isLoaded = true;
                    runBtn.disabled = false;
                    stepBtn.disabled = false;
                    pauseBtn.disabled = true;
                    updateStatus('Ready to run.', 'ok');
                    updateRegisterView();
                } catch (err) {
                    console.error("Loading error:", err);
                    updateStatus(err.message, 'error');
                    isLoaded = false;
                    runBtn.disabled = true;
                    stepBtn.disabled = true;
                    pauseBtn.disabled = true;
                }
            });

            runBtn.addEventListener('click', () => {
                if (!isLoaded || isHalted) return;
                isRunning = true;
                isPausedAtBreakpoint = false;
                runBtn.disabled = true; stepBtn.disabled = true; stepOverBtn.disabled = true;
                loadBtn.disabled = true; pauseBtn.disabled = false;
                updateStatus('Running...', 'ok');
                runEmulationCycle();
            });

            pauseBtn.addEventListener('click', () => pauseEmulation('Paused by user.', 'pending'));

            stepBtn.addEventListener('click', () => {
                if (!isLoaded || isHalted || isRunning) return;
                singleStep();
                updateInstructionLogUI();
                updateRegisterView();
            });

            stepOverBtn.addEventListener('click', () => {
                if (!isLoaded || isHalted || isRunning || !isPausedAtBreakpoint) return;
                const success = executeSingleInstruction();
                isPausedAtBreakpoint = false;
                updateInstructionLogUI();
                updateRegisterView();
                if (success && !isHalted) {
                    runBtn.disabled = false; stepBtn.disabled = false; stepOverBtn.disabled = true;
                    pauseBtn.disabled = true; loadBtn.disabled = false;
                    updateStatus('Stepped. Paused.', 'pending');
                }
            });

            term.onKey(({ key, domEvent }) => {
                // Don't process input if the emulator isn't loaded and ready
                if (!isLoaded) {
                    return;
                }
                
                // The terminal is dumb. It only sends keystrokes to the emulator's
                // buffer. The emulator itself is responsible for echoing characters back
                // to the console via its OUT instruction.

                if (domEvent.key === 'Enter') {
                    // Send the carriage return character (ASCII 13) to the emulator.
                    z80.keyboardBuffer.push(13n);
                } else if (domEvent.key === 'Backspace') {
                    // Send the backspace character (ASCII 8) to the emulator.
                    z80.keyboardBuffer.push(8n);
                } else if (!domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey && domEvent.key.length === 1) {
                    // Handle regular, printable characters. This check prevents control keys
                    // (like Shift, Alt, etc.) from being sent as printable chars.
                    
                    // Send the character's ASCII code to the emulator's buffer.
                    z80.keyboardBuffer.push(BigInt(key.charCodeAt(0)));
                }
            });


            clearSessionBtn.addEventListener('click', () => {
                localStorage.clear();
                window.location.reload(); 
            });
            
            function updateBreakpointListUI() {
                breakpointList.innerHTML = '';
                const sortedAddrs = Array.from(breakpoints.keys()).sort((a, b) => a - b);
                for (const addr of sortedAddrs) {
                    const bpState = breakpoints.get(addr);
                    const li = document.createElement('li');
                    const addrHex = `0x${addr.toString(16).toUpperCase().padStart(4, '0')}`;
                    li.innerHTML = `<input type="checkbox" class="bp-toggle" data-addr="${addr}" ${bpState.enabled ? 'checked' : ''}><span>${addrHex}</span><button class="remove-bp-btn" data-addr="${addr}">X</button>`;
                    if (!bpState.enabled) {
                        li.querySelector('span').style.textDecoration = 'line-through';
                        li.querySelector('span').style.opacity = '0.6';
                    }
                    breakpointList.appendChild(li);
                }
            }
            
            addBreakpointBtn.addEventListener('click', () => {
                const addrStr = breakpointAddressInput.value.trim();
                if (!addrStr) return;
                const addr = parseInt(addrStr, 16);
                if (isNaN(addr)) { alert('Invalid hexadecimal address.'); return; }
                breakpoints.set(addr, { enabled: true });
                updateBreakpointListUI();
                breakpointAddressInput.value = '';
                breakpointAddressInput.focus();
            });
            
            breakpointAddressInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addBreakpointBtn.click(); });
            
            breakpointList.addEventListener('click', (e) => {
                const target = e.target;
                if (target.classList.contains('remove-bp-btn')) {
                    breakpoints.delete(parseInt(target.dataset.addr, 10));
                    updateBreakpointListUI();
                } else if (target.classList.contains('bp-toggle')) {
                    const bp = breakpoints.get(parseInt(target.dataset.addr, 10));
                    if (bp) bp.enabled = target.checked;
                    updateBreakpointListUI();
                }
            });

            // --- Initial Setup ---
            logger.disable();
            const savedArch = localStorage.getItem('savedArchContent');
            const savedRom = localStorage.getItem('savedRomContentBase64');
            if (savedArch && savedRom) {
                cachedArchContent = savedArch;
                cachedRomBytes = base64ToArrayBuffer(savedRom);
                archFileInfo.textContent = `(${localStorage.getItem('savedArchFilename')})`;
                binFileInfo.textContent = `(${localStorage.getItem('savedRomFilename')})`;
                loadBtn.disabled = false;
                updateStatus('Saved session found. Press "Load & Reset".', 'ok');
            } else {
                updateStatus('Select files to begin.', 'pending');
            }
        }
    });
</script>
</body>
</html>