# yaml-language-server: $schema=schema.json
version: 2.0.0

config:
  name: Z80
  word_size: 8 # 8-bit word size, which is the same as the byte size
  byte_size: 8
  description: Z80
  endianness: little_endian
  memory_alignment: true
  main_function: main
  passing_convention: true
  sensitive_register_name: true
  comment_prefix: ";"
  start_address: 0x0
  pc_offset: 0
  plugin: z80
  syntax: z80
  assemblers:
    - name: "RASM"
      description: "RASM Z80 Assembler"

components:
  - name: Control registers
    type: ctrl_registers
    double_precision: false
    elements:
      - name:
          - PC
        nbits: 16
        value: 0
        default_value: 0
        encoding: 0
        properties:
          - read
          - write
          - program_counter
  - name: Integer registers
    type: int_registers
    double_precision: false
    elements:
      - name: [A]
        nbits: 8
        value: 0
        encoding: 7
        default_value: 0
        properties: [read, write]
      - name: [B]
        nbits: 8
        value: 0
        encoding: 0
        default_value: 0
        properties: [read, write]
      - name: [C]
        nbits: 8
        value: 0
        encoding: 1
        default_value: 0
        properties: [read, write]
      - name: [D]
        nbits: 8
        encoding: 2
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [E]
        nbits: 8
        encoding: 3
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [H]
        nbits: 8
        encoding: 4
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [L]
        nbits: 8
        encoding: 5
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [I]
        nbits: 8
        encoding: 8
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [R]
        nbits: 8
        encoding: 23
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["A_prime"]
        nbits: 8
        encoding: 9
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["B_prime"]
        nbits: 8
        encoding: 10
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["C_prime"]
        nbits: 8
        encoding: 11
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["D_prime"]
        nbits: 8
        encoding: 12
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["E_prime"]
        nbits: 8
        encoding: 13
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["H_prime"]
        nbits: 8
        encoding: 14
        value: 0
        default_value: 0
        properties: [read, write]
      - name: ["L_prime"]
        nbits: 8
        encoding: 15
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [SP]
        nbits: 16
        encoding: 16
        value: 65535
        default_value: 65535
        properties: [read, write, stack_pointer]
      - name: [IX]
        nbits: 16
        encoding: 17
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [IY]
        nbits: 16
        encoding: 18
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [F]
        nbits: 8
        encoding: 19
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [F_prime]
        nbits: 8
        encoding: 20
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [IFF1]
        nbits: 1
        encoding: 21
        value: 0
        default_value: 0
        properties: [read, write]
      - name: [IFF2]
        nbits: 1
        encoding: 22
        value: 0
        default_value: 0
        properties: [read, write]

memory_layout:
  text:
    start: 0x0000
    end: 0x03FF
  data:
    start: 0x0400
    end: 0x7FFF
  stack:
    start: 0xFFFE
    end: 0xFFFF

templates:
  # Main Instructions
  - name: standard
    nwords: 1
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
  
  - name: alu_implicit # ALU Instructions (ADD ADC SBC)
    nwords: 1
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 6
        order: 0
        value: "10"
      - name: instructionFormatting
        type: skip
        value: "a"
        suffix: ","
        order: 1
      - name: operation
        type: cop
        startbit: 5
        stopbit: 3
      - name: src
        type: INT-Reg
        startbit: 2
        stopbit: 0
        order: 2

  - name: alu # ALU Instructions (SUB AND XOR OR CP)
    nwords: 1
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 6
        order: 0
        value: "10"
      - name: operation
        type: cop
        startbit: 5
        stopbit: 3
      - name: src
        type: INT-Reg
        startbit: 2
        stopbit: 0
        order: 1

  # These names match the opcode tables in the official z80 documentation.
  # pg. 42 of UM008011-0816
  - name: ld_8b # LD r, r'
    nwords: 1
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 6
        order: 0
        value: "01"

  - name: ld_8b_srcRegIndirect # LD r, (HL)
    nwords: 1
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 6
        order: 0
        value: "01"
      - name: src
        type: cop
        startbit: 2
        stopbit: 0
        value: "110"
  
  - name: ld_8b_dstRegIndirect # LD (HL), r
    nwords: 1
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 6
        order: 0
        value: "01"
      - name: dst
        type: cop
        startbit: 5
        stopbit: 3
        value: "110"

  - name: ld_8b_srcIndexed
    nwords: 3
    clk_cycles: 19
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11011101" # DD
      - name: d
        type: imm-signed
        startbit: 23
        stopbit: 16
        prefix: "(IX+"
        suffix: ")"
        order: 2

  - name: ld_8b_srcImm
    nwords: 2
    clk_cycles: 7
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 6
        order: 0
        value: "00"
      - name: n
        type: imm-unsigned
        startbit: 15
        stopbit: 8
        order: 2

  # IX Bit Instructions
  - name: DDCB
    nwords: 4
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11011101"
      - name: opcode2
        type: cop
        startbit: 15
        stopbit: 8
        value: "11001011"
      - name: imm
        type: imm-unsigned
        startbit: 23
        stopbit: 16
        prefix: "("
        suffix: ")"
        order: 1
      - name: opcode3
        type: cop
        startbit: 31
        stopbit: 24

  # IX Instructions
  - name: DD
    nwords: 2
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11011101"
      - name: opcode2
        type: cop
        startbit: 15
        stopbit: 8

  # Misc. Instructions
  - name: ED
    nwords: 2
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11101101"
      - name: opcode2
        type: cop
        startbit: 15
        stopbit: 8

  # IY Instructions
  - name: FD
    nwords: 2
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11111101"
      - name: opcode2
        type: cop
        startbit: 15
        stopbit: 8

  # IY Bit Instructions (IY-prefixed CB instructions)
  - name: FDCB
    nwords: 4
    clk_cycles: 1 # Base, will be overridden by instruction
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11111101" # 0xFD prefix
      - name: opcode2
        type: cop
        startbit: 15
        stopbit: 8
        value: "11001011" # 0xCB prefix
      - name: d
        type: imm-signed
        startbit: 23
        stopbit: 16
      - name: opcode3
        type: cop
        startbit: 31
        stopbit: 24

  # Bit Instructions
  - name: CB
    nwords: 2
    clk_cycles: 1
    fields:
      - name: opcode
        type: co
        startbit: 7
        stopbit: 0
        order: 0
        value: "11001011"
      - name: opcode2
        type: cop
        startbit: 15
        stopbit: 8

instructions:
  base:
    - name: nop
      template: standard
      fields:
        - field: opcode
          value: "0x00"
      definition: ""

    - name: ld
      template: standard
      nwords: 3
      fields:
        - field: opcode
          value: "0x01"
        - field: instructionFormatting
          type: skip
          value: "bc,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23 # Two words
          stopbit: 8
          order: 2
      definition: |
        // Loads 16-bit immediate into BC. Low byte to C, high byte to B.
        registers.C = nn & 0xFFn;
        registers.B = (nn >> 8n) & 0xFFn;

    - name: rlca
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x07"
      definition: |
        const msb = (registers.A & 0x80n) ? 1n : 0n;
        registers.A = ((registers.A << 1n) | msb) & 0xFFn;
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.PV_FLAG); // Preserve S, Z, P/V
        if (msb) newF |= CAPI.ARCH.C_FLAG; // Set C if bit 7 was 1
        // N and H are reset
        registers.F = newF;

    - name: ex
      template: standard
      nwords: 1
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x08"
        - field: instructionFormatting
          type: skip
          value: "af,af'"
          order: 1
      definition: |
        // Exchanges the 16-bit contents of AF and AF'.
        let temp_reg;

        temp_reg = registers.A;
        registers.A = registers.A_prime;
        registers.A_prime = temp_reg;

        temp_reg = registers.F;
        registers.F = registers.F_prime;
        registers.F_prime = temp_reg;

    - name: djnz
      template: standard
      nwords: 2
      clk_cycles: 13 # 8 if not taken
      fields:
        - field: opcode
          value: "0x10"
        - field: e
          type: imm-signed
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        registers.B = (registers.B - 1n) & 0xFFn;
        if (registers.B !== 0n) {
            // PC is already at address of next instruction, so add offset.
            registers.PC = (registers.PC + e) & 0xFFFFn;
        }

    - name: ld
      template: standard
      nwords: 3
      fields:
        - field: opcode
          value: "0x11"
        - field: instructionFormatting
          type: skip
          value: "de,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        // Loads 16-bit immediate into DE. Low byte to E, high byte to D.
        registers.E = nn & 0xFFn;
        registers.D = (nn >> 8n) & 0xFFn;

    - name: ld
      template: standard
      nwords: 3
      fields:
        - field: opcode
          value: "0x21"
        - field: instructionFormatting
          type: skip
          value: "hl,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        // Loads 16-bit immediate into HL. Low byte to L, high byte to H.
        registers.L = nn & 0xFFn;
        registers.H = (nn >> 8n) & 0xFFn;

    - name: cmp
      template: standard
      nwords: 1
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x2f"
      definition: |
        // The contents of A are inverted (one's complement)
        registers.A = (~registers.A) & 0xFFn;

    - name: ld
      template: standard
      nwords: 3
      fields:
        - field: opcode
          value: "0x31"
        - field: instructionFormatting
          type: skip
          value: "sp,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        // Loads 16-bit immediate into SP.
        registers.SP = nn;

    - name: jp
      template: standard
      nwords: 3
      fields:
        - field: opcode
          value: "0xC3"
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 1
      definition: "registers.PC = nn;"

    - name: jr
      template: standard
      nwords: 2
      clk_cycles: 12
      fields:
        - field: opcode
          value: "0x18"
        - field: e
          type: imm-signed
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        // PC is already at address of next instruction, so add offset.
        registers.PC = (registers.PC + e) & 0xFFFFn;
    - name: jr
      template: standard
      nwords: 2
      clk_cycles: 12 # 7 if not taken
      fields:
        - field: opcode
          value: "0x20"
        - field: instructionFormatting
          type: skip
          value: "nz,"
          order: 1
        - field: e
          type: imm-signed
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        // If the zero flag is unset, the signed value d is added to PC. 
        // The jump is measured from the start of the instruction opcode. 
        if ((registers.F & CAPI.ARCH.Z_FLAG) === 0n) {
            registers.PC = (registers.PC + e) & 0xFFFFn;
        }
    - name: jr
      template: standard
      nwords: 2
      clk_cycles: 12 # 7 if not taken
      fields:
        - field: opcode
          value: "0x28"
        - field: instructionFormatting
          type: skip
          value: "z,"
          order: 1
        - field: e
          type: imm-signed
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) !== 0n) {
            registers.PC = (registers.PC + e) & 0xFFFFn;
        }
    - name: jr
      template: standard
      nwords: 2
      clk_cycles: 12 # 7 if not taken
      fields:
        - field: opcode
          value: "0x30"
        - field: instructionFormatting
          type: skip
          value: "nc,"
          order: 1
        - field: e
          type: imm-signed
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) === 0n) {
            registers.PC = (registers.PC + e) & 0xFFFFn;
        }
    - name: jr
      template: standard
      nwords: 2
      clk_cycles: 12 # 7 if not taken
      fields:
        - field: opcode
          value: "0x38"
        - field: instructionFormatting
          type: skip
          value: "c,"
          order: 1
        - field: e
          type: imm-signed
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) !== 0n) {
            registers.PC = (registers.PC + e) & 0xFFFFn;
        }
    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xC2"
        - field: instructionFormatting
          type: skip
          value: "nz,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) === 0n) {
            registers.PC = nn;
        }
    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xCA"
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
        - field: instructionFormatting
          type: skip
          value: "z,"
          order: 1
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) !== 0n) {
            registers.PC = nn;
        }
    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xD2"
        - field: instructionFormatting
          type: skip
          value: "nc,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) === 0n) {
            registers.PC = nn;
        }

    - name: out
      template: standard
      nwords: 2
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xD3"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          prefix: "("
          suffix: ")"
          order: 1
        - field: instructionFormatting
          type: skip
          value: ",a"
          order: 2
      definition: |
        // Writes the value of the Accumulator to the I/O port specified by n.
        CAPI.ARCH.write(n, registers.A);

    - name: rst 00h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xC7"
      definition: |
        // Push the address of the next instruction onto the stack.
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        // Jump to the RST address.
        registers.PC = 0x00n;

    - name: rst 10h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xD7"
      definition: |
        // Push the address of the next instruction onto the stack.
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        // Jump to the RST address.
        registers.PC = 0x10n;

    - name: rst 20h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xE7"
      definition: |
        // Push the address of the next instruction onto the stack.
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        // Jump to the RST address.
        registers.PC = 0x20n;

    - name: rst 30h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xF7"
      definition: |
        // Push the address of the next instruction onto the stack.
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        // Jump to the RST address.
        registers.PC = 0x30n;

    - name: in
      template: standard
      nwords: 2
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xDB"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          prefix: "("
          suffix: ")"
          order: 2
        - field: instructionFormatting
          type: skip
          value: ",a"
          order: 1
      definition: |
        // Reads a byte from the I/O port specified by n and stores it in the Accumulator.
        registers.A = CAPI.ARCH.read(n);

    - name: sbc
      template: standard
      nwords: 2
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xDE"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        const oldValueA = registers.A;
        const carry = registers.F & 0x01n;
        registers.A = (oldValueA - n - carry) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SBC(oldValueA, n, registers.F);

    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xDA"
        - field: instructionFormatting
          type: skip
          value: "c,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) !== 0n) {
            registers.PC = nn;
        }
    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xE2"
        - field: instructionFormatting
          type: skip
          value: "po,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.PV_FLAG) === 0n) {
            registers.PC = nn;
        }

    - name: ex
      template: standard
      nwords: 1
      clk_cycles: 19
      fields:
        - field: opcode
          value: "0xE3"
        - field: instructionFormatting
          type: skip
          value: "(sp),hl"
          order: 1
      definition: |
        // Exchanges (registers.SP) with L, and (registers.SP+1) with H.
        const temp_L = registers.L;
        const temp_H = registers.H;
        const stack_low = CAPI.MEM.read(registers.SP, 1);
        const stack_high = CAPI.MEM.read(registers.SP + 1n, 1);

        registers.L = stack_low;
        registers.H = stack_high;

        CAPI.MEM.write(registers.SP, 1, temp_L);
        CAPI.MEM.write(registers.SP + 1n, 1, temp_H);

    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xEA"
        - field: instructionFormatting
          type: skip
          value: "pe,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.PV_FLAG) !== 0n) {
            registers.PC = nn;
        }

    - name: ex
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0xEB"
        - field: instructionFormatting
          type: skip
          value: "de, hl"
          order: 1
      definition: |
        // Exchanges the 16-bit contents of the DE and HL register pairs.
        let temp_reg;

        temp_reg = registers.D;
        registers.D = registers.H;
        registers.H = temp_reg;

        temp_reg = registers.E;
        registers.E = registers.L;
        registers.L = temp_reg;

    - name: jp (hl)
      template: standard
      nwords: 1
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0xE9"
      definition: |
        registers.PC = (registers.H << 8n) | registers.L;
    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xF2"
        - field: instructionFormatting
          type: skip
          value: "p,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.S_FLAG) === 0n) {
            registers.PC = nn;
        }
    - name: jp
      template: standard
      nwords: 3
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xFA"
        - field: instructionFormatting
          type: skip
          value: "m,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.S_FLAG) !== 0n) {
            registers.PC = nn;
        }
  ################################################################################ 
  # 8-bit Load Group LD
  # Destination: Register
  # Source: Implied
    - name: ld
      template: ED
      nwords: 2
      clk_cycles: 9
      fields:
        - field: opcode2
          value: "0x57"
        - field: instructionFormatting
          type: skip
          value: "A, I"
          order: 1
      definition: |
        // Loads the value of I into A.
        registers.A = registers.I;

    - name: ld
      template: ED
      nwords: 2
      clk_cycles: 9
      fields:
        - field: opcode2
          value: "0x5F"
        - field: instructionFormatting
          type: skip
          value: "A, R"
          order: 1
      definition: |
        // Loads the value of R into A.
        registers.A = registers.R;
  
  ################################################################################ 
  # 8-bit Load Group LD
  # Destination: Register
  # Source: Register
    - name: ld
      template: ld_8b
      nwords: 1
      clk_cycles: 4
      fields:
        - field: dest
          type: INT-Reg
          startbit: 5
          stopbit: 3
          order: 1
          suffix: ","
        - field: src
          type: INT-Reg
          startbit: 2
          stopbit: 0
          order: 2
      definition: |
        registers[dest] = registers[src];  

  ################################################################################ 
  # 8-bit Load Group LD
  # Destination: Register
  # Source: Indexed
    - name: ld
      template: ld_8b_srcIndexed
      nwords: 3
      clk_cycles: 19
      fields:
      - field: dest
        type: INT-Reg
        startbit: 13
        stopbit: 11
        order: 1
        suffix: ","

      definition: |
        // Loads the value pointed to by IX plus d into destination register.
        const addr = (registers.IX + d) & 0xFFFFn;
        registers[dest] = CAPI.MEM.read(addr, 1);

    - name: ld
      template: ld_8b_srcIndexed
      nwords: 3
      clk_cycles: 19
      fields:
      - field: opcode
        value: "0xFD"
      - field: dest
        type: INT-Reg
        startbit: 13
        stopbit: 11
        order: 1
        suffix: ","

      definition: |
        // Loads the value pointed to by IY plus d into destination register.
        const addr = (registers.IY + d) & 0xFFFFn;
        registers[dest] = CAPI.MEM.read(addr, 1);

  ################################################################################ 
  # 8-bit Load Group LD
  # Destination: Register
  # Source: Ext. Addr.

    - name: ld
      template: standard
      nwords: 3
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x3a"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          prefix: "("
          suffix: ")"
          order: 2
      definition: |
        // Loads the value pointed to by nn into A.
        const value = CAPI.MEM.read(nn, 1);
        registers.A = value & 0xFFn;

  ################################################################################
  # 8-bit Load Group LD
  # Destination: Register
  # Source: Immediate
    - name: ld
      template: ld_8b_srcImm
      nwords: 2
      fields:
        - field: dst
          type: INT-Reg
          startbit: 5
          stopbit: 3
          order: 1
          suffix: ","
      definition: |
        registers[dst] = n;

  ################################################################################
  # 8-bit Load Group LD
  # Destination: Register
  # Source: Register Indirect
    - name: ld
      template: ld_8b_srcRegIndirect
      nwords: 1
      clk_cycles: 7
      fields:
        - field: dest
          type: INT-Reg
          startbit: 5
          stopbit: 3
          order: 1
          suffix: ", (HL)"
      definition: |
        registers[dest] = CAPI.MEM.read((registers.H << 8n) | registers.L, 1);

    - name: ld
      template: standard
      nwords: 1
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x0a"
        - field: instructionFormatting
          type: skip
          value: "a, (BC)"
          order: 1
      definition: |
        registers.A = CAPI.MEM.read((registers.B << 8n) | registers.C, 1);

    - name: ld
      template: standard
      nwords: 1
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x1a"
        - field: instructionFormatting
          type: skip
          value: "a, (DE)"
          order: 1
      definition: |
        registers.A = CAPI.MEM.read((registers.D << 8n) | registers.E, 1);

  ################################################################################ 
  # 8-bit Load Group LD
  # Destination: Register Indirect
  # Source: Register

    - name: ld
      template: ld_8b_dstRegIndirect
      nwords: 1
      clk_cycles: 7
      fields:
        - field: src
          type: INT-Reg
          startbit: 2
          stopbit: 0
          prefix: "(HL), "
          order: 1
      definition: |
        CAPI.MEM.write((registers.H << 8n) | registers.L, 1, registers[src]);

    - name: ld
      template: standard
      nwords: 1
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x02"
        - field: instructionFormatting
          type: skip
          value: "(bc), a"
          order: 1
      definition: |
        CAPI.MEM.write((registers.B << 8n) | registers.C, 1, registers.A);

    - name: ld
      template: standard
      nwords: 1
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x12"
        - field: instructionFormatting
          type: skip
          value: "(de), a"
          order: 1
      definition: |
        CAPI.MEM.write((registers.D << 8n) | registers.E, 1, registers.A);
        
  ###############################################################################
  # 8-bit Load Group LD
  # Destination: Indexed
  # Source: Immediate

    - name: ld
      template: FD
      nwords: 4
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x36"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting
          type: skip
          value: "),"
          order: 3
        - field: n
          type: imm-unsigned
          startbit: 31
          stopbit: 24
          order: 4
      definition: |
        // Loads the immediate value n into the memory location (IY + d).
        const addr = (registers.IY + d) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, n);

  ################################################################################
  # 8-bit Load Group LD
  # Destination: Register Indirect
  # Source: Immediate
    - name: ld # (hl), n
      template: standard
      nwords: 2
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0x36"
        - field: instructionFormatting
          type: skip
          value: "(hl),"
          order: 1
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        CAPI.MEM.write((registers.H << 8n) | registers.L, 1, n);

  ################################################################################
  # 8-bit Load Group LD
  # Destination: Ext. Addr.
  # Source: Register

    - name: ld
      template: standard
      nwords: 3
      clk_cycles: 13
      fields:
        - field: opcode
          value: "0x32"
        - field: instructionFormatting
          type: skip
          value: ", a"
          order: 2
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          prefix: "("
          suffix: ")"
          order: 1
      definition: |
        CAPI.MEM.write(nn, 1, registers.A);

  ################################################################################


    - name: add # a, b
      template: alu_implicit
      fields:
        - field: operation
          value: "000"

      definition: |
        const oldValueA = registers.A;
        const value = registers[src];
        registers.A = (oldValueA + value) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADD(oldValueA, value);

    - name: add a, (hl)
      template: standard
      clk_cycles: 2
      fields:
        - field: opcode
          value: "0x86"
      definition: |
        const value = CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        const oldValueA = registers.A;
        registers.A = (oldValueA + value) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADD(oldValueA, value);

    - name: adc # a, r
      template: alu_implicit
      fields:
        - field: operation
          value: "001"
      definition: |
        const oldValueA = registers.A;
        const value = registers[src];
        registers.A = (oldValueA + value + (registers.F & 0x01n)) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADC(oldValueA, value, registers.F);

    - name: adc a, (hl)
      template: standard
      clk_cycles: 2
      fields:
        - field: opcode
          value: "0x8E"
      definition: |
        const value = CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        const oldValueA = registers.A;
        registers.A = (oldValueA + value + (registers.F & 0x01n)) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADC(oldValueA, value, registers.F);

    - name: sub # r
      template: alu
      clk_cycles: 4
      fields:
        - field: operation
          value: "010"
      definition: |
        const oldValueA = registers.A;
        const value = registers[src];
        registers.A = (oldValueA - value) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SUB(oldValueA, value);
    - name: sub (hl)
      template: standard
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x96"
      definition: |
        const value = CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        const oldValueA = registers.A;
        registers.A = (oldValueA - value) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SUB(oldValueA, value);

    - name: sub
      template: standard
      clk_cycles: 7
      nwords: 2
      fields:
        - field: opcode
          value: "0xD6"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        const oldValueA = registers.A;
        registers.A = (oldValueA - n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SUB(oldValueA, n);

    - name: sbc # a, r
      template: alu_implicit
      clk_cycles: 4
      fields:
        - field: operation
          value: "011"
      definition: |
        const oldValueA = registers.A;
        const value = registers[src];
        const carry = registers.F & 0x01n;
        registers.A = (oldValueA - value - carry) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SBC(oldValueA, value, registers.F);
    - name: sbc a, (hl)
      template: standard
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x9E"
      definition: |
        const value = CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        const oldValueA = registers.A;
        const carry = registers.F & 0x01n;
        registers.A = (oldValueA - value - carry) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SBC(oldValueA, value, registers.F);
    - name: sbc a, a
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x9F"
      definition: |
        const carry = registers.F & CAPI.ARCH.C_FLAG;

        if (carry === 0n) {
            // Operation is A - A - 0. Result is 0.
            registers.A = 0n;
            // Flags: S=0, Z=1, H=0, P/V=0, N=1, C=0
            registers.F = CAPI.ARCH.Z_FLAG | CAPI.ARCH.N_FLAG; 
        } else {
            // Operation is A - A - 1. Result is -1 (0xFF).
            registers.A = 0xFFn;
            // Flags: S=1, Z=0, H=1, P/V=0, N=1, C=1
            registers.F = CAPI.ARCH.S_FLAG | CAPI.ARCH.H_FLAG | CAPI.ARCH.N_FLAG | CAPI.ARCH.C_FLAG;
        }
    - name: and # r
      template: alu
      clk_cycles: 4
      fields:
        - field: operation
          value: "100"
      definition: |
        registers.A = registers.A & registers[src];
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 1);
    - name: and (hl)
      template: standard
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xA6"
      definition: |
        registers.A = registers.A & CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 1);

    - name: and
      template: standard
      nwords: 2
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xE6"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        registers.A = registers.A & n;
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 1);
    - name: xor # r
      template: alu
      clk_cycles: 4
      fields:
        - field: operation
          value: "101"
      definition: |
        registers.A = registers.A ^ registers[src];
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);
    - name: xor (hl)
      template: standard
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xAE"
      definition: |
        registers.A = registers.A ^ CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);

    - name: or # r
      template: alu
      clk_cycles: 4
      fields:
        - field: operation
          value: "110"
      definition: |
        registers.A = registers.A | registers[src];
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);
    - name: or (hl)
      template: standard
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xB6"
      definition: |
        registers.A = registers.A | CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);

    - name: cp # r
      template: alu
      clk_cycles: 4
      fields:
        - field: operation
          value: "111"
      definition: |
        registers.F = CAPI.ARCH.calculateFlags_CP(registers.A, registers[src]);
    - name: cp (hl)
      template: standard
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xBE"
      definition: |
        const value = CAPI.MEM.read((registers.H << 8n) | registers.L, 1);
        registers.F = CAPI.ARCH.calculateFlags_CP(registers.A, value);
    - name: cp
      template: standard
      nwords: 2
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xFE"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        registers.F = CAPI.ARCH.calculateFlags_CP(registers.A, n);

    - name: adc
      template: standard
      nwords: 2
      clk_cycles: 2
      fields:
        - field: opcode
          value: "0xCE"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        const oldValueA = registers.A;
        registers.A = (oldValueA + n + (registers.F & 0x01n)) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADC(oldValueA, n, registers.F);

    - name: add
      template: standard
      nwords: 2
      clk_cycles: 2
      fields:
        - field: opcode
          value: "0xC6"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 2
      definition: |
        const oldValue = registers.A;
        registers.A = (oldValue + n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADD(oldValue, n);

    - name: ld
      template: standard
      nwords: 3
      clk_cycles: 16
      fields:
        - field: opcode
          value: "0x22"
        - field: instructionFormatting
          type: skip
          value: "hl"
          order: 2
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          prefix: "("
          suffix: ")"
          order: 1
      definition: |
        CAPI.MEM.write(nn, 1, registers.L);
        CAPI.MEM.write(nn + 1n, 1, registers.H);

    - name: inc bc
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x03"
      definition: |
        // Increments 16-bit BC. No flags are affected.
        const value = (((registers.B << 8n) | registers.C) + 1n) & 0xFFFFn;
        registers.B = (value >> 8n) & 0xFFn;
        registers.C = value & 0xFFn;

    - name: inc de
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x13"
      definition: |
        // Increments 16-bit DE. No flags are affected.
        const value = (((registers.D << 8n) | registers.E) + 1n) & 0xFFFFn;
        registers.D = (value >> 8n) & 0xFFn;
        registers.E = value & 0xFFn;

    - name: inc hl
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x23"
      definition: |
        // Increments 16-bit HL. No flags are affected.
        const value = (((registers.H << 8n) | registers.L) + 1n) & 0xFFFFn;
        registers.H = (value >> 8n) & 0xFFn;
        registers.L = value & 0xFFn;

    - name: inc sp
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x33"
      definition: |
        // Increments 16-bit SP. No flags are affected.
        registers.SP = (registers.SP + 1n) & 0xFFFFn;

    - name: dec bc
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x0B"
      definition: |
        // Decrements 16-bit BC. No flags are affected.
        const value = (((registers.B << 8n) | registers.C) - 1n) & 0xFFFFn;
        registers.B = (value >> 8n) & 0xFFn;
        registers.C = value & 0xFFn;

    - name: dec de
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x1B"
      definition: |
        // Decrements 16-bit DE. No flags are affected.
        const value = (((registers.D << 8n) | registers.E) - 1n) & 0xFFFFn;
        registers.D = (value >> 8n) & 0xFFn;
        registers.E = value & 0xFFn;

    - name: dec hl
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x2B"
      definition: |
        // Decrements 16-bit HL. No flags are affected.
        const value = (((registers.H << 8n) | registers.L) - 1n) & 0xFFFFn;
        registers.H = (value >> 8n) & 0xFFn;
        registers.L = value & 0xFFn;

    - name: dec sp
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0x3B"
      definition: |
        // Decrements 16-bit SP. No flags are affected.
        registers.SP = (registers.SP - 1n) & 0xFFFFn;

    - name: add
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0x09"
        - field: instructionFormatting
          type: skip
          value: "hl, bc"
          order: 1
      definition: |
        const hlValue = (registers.H << 8n) | registers.L;
        const bcValue = (registers.B << 8n) | registers.C;
        const result = hlValue + bcValue;
        registers.F = CAPI.ARCH.calculateFlags_ADD16(hlValue, bcValue, registers.F);
        const resultWord = result & 0xFFFFn;
        registers.H = (resultWord >> 8n) & 0xFFn;
        registers.L = resultWord & 0xFFn;

    - name: add
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0x19"
        - field: instructionFormatting
          type: skip
          value: "hl, de"
          order: 1
      definition: |
        // Adds the value of DE to HL.
        const hlValue = (registers.H << 8n) | registers.L;
        const deValue = (registers.D << 8n) | registers.E;
        registers.F = CAPI.ARCH.calculateFlags_ADD16(hlValue, deValue, registers.F);
        const result = (hlValue + deValue) & 0xFFFFn;
        registers.H = (result >> 8n) & 0xFFn;
        registers.L = result & 0xFFn;

    - name: add
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0x29"
        - field: instructionFormatting
          type: skip
          value: "hl, hl"
          order: 1
      definition: |
        const hlValue = (registers.H << 8n) | registers.L;
        const result = hlValue + hlValue;
        registers.F = CAPI.ARCH.calculateFlags_ADD16(hlValue, hlValue, registers.F);
        const resultWord = result & 0xFFFFn;
        registers.H = (resultWord >> 8n) & 0xFFn;
        registers.L = resultWord & 0xFFn;

    - name: add
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0x39"
        - field: instructionFormatting
          type: skip
          value: "hl, sp"
          order: 1
      definition: |
        const hlValue = (registers.H << 8n) | registers.L;
        const result = hlValue + registers.SP;
        registers.F = CAPI.ARCH.calculateFlags_ADD16(hlValue, registers.SP, registers.F);
        const resultWord = result & 0xFFFFn;
        registers.H = (resultWord >> 8n) & 0xFFn;
        registers.L = resultWord & 0xFFn;

    - name: ld
      template: standard
      nwords: 3
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0x2a"
        - field: instructionFormatting
          type: skip
          value: "hl,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          prefix: "("
          suffix: ")"
          order: 2
      definition: |
        // Loads the value pointed to by nn into HL.
        registers.L = CAPI.MEM.read(nn, 1); // little endian
        registers.H = CAPI.MEM.read(nn + 1n, 1);

    - name: inc c
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x0c"
      definition: |
        const oldValue = registers.C;
        registers.C = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: inc e
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x1c"
      definition: |
        const oldValue = registers.E;
        registers.E = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: inc l
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x2c"
      definition: |
        const oldValue = registers.L;
        registers.L = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: inc a
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x3c"
      definition: |
        const oldValue = registers.A;
        registers.A = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: dec c
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x0d"
      definition: |
        const oldValue = registers.C;
        registers.C = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: rrca
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x0F"
      definition: |
        const lsb = registers.A & 0x01n;
        registers.A = (registers.A >> 1n) | (lsb << 7n);
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.PV_FLAG); // Preserve S, Z, P/V
        if (lsb) newF |= CAPI.ARCH.C_FLAG; // Set C if bit 0 was 1
        // N and H are reset
        registers.F = newF;

    - name: rra
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x1F"
      definition: |
        // The contents of A are rotated right one bit position.
        // Bit 0 is copied to the Carry flag, and the old Carry flag is copied to bit 7.
        const oldCarry = registers.F & CAPI.ARCH.C_FLAG;
        const newCarry = registers.A & 0x01n;

        registers.A = ((registers.A >> 1n) | (oldCarry << 7n)) & 0xFFn;

        // Preserve S, Z, P/V. Reset H, N. Set C from bit 0 of original A.
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.PV_FLAG);
        newF |= newCarry; // newCarry is 0n or 1n, which corresponds to C_FLAG value
        registers.F = newF;

    - name: dec e
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x1d"
      definition: |
        const oldValue = registers.E;
        registers.E = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: dec l
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x2d"
      definition: |
        const oldValue = registers.L;
        registers.L = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: dec a
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x3d"
      definition: |
        const oldValue = registers.A;
        registers.A = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: inc b
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x04"
      definition: |
        const oldValue = registers.B;
        registers.B = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: inc d
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x14"
      definition: |
        const oldValue = registers.D;
        registers.D = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: rla
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x17"
      definition: |
        const carry = registers.F & CAPI.ARCH.C_FLAG;
        const msb = (registers.A & 0x80n) ? 1n : 0n;
        registers.A = ((registers.A << 1n) | carry) & 0xFFn;
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.PV_FLAG); // Preserve S, Z, P/V
        if (msb) newF |= CAPI.ARCH.C_FLAG; // Set C if bit 7 was 1
        // N and H are reset
        registers.F = newF;

    - name: inc h
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x24"
      definition: |
        const oldValue = registers.H;
        registers.H = (oldValue + 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: inc (hl)
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0x34"
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const oldValue = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, (oldValue + 1n) & 0xFFn);
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: dec b
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x05"
      definition: |
        const oldValue = registers.B;
        registers.B = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: dec d
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x15"
      definition: |
        const oldValue = registers.D;
        registers.D = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: dec h
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x25"
      definition: |
        const oldValue = registers.H;
        registers.H = (oldValue - 1n) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: dec (hl)
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0x35"
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const oldValue = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, (oldValue - 1n) & 0xFFn);
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: ccf
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x3F"
      definition: |
        // Complement Carry Flag.
        const oldCarrySet = (registers.F & CAPI.ARCH.C_FLAG) !== 0n;
        // Preserve S, Z, and P/V flags from the original F register.
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.PV_FLAG);

        if (oldCarrySet) {
            // If the old carry was set (1), the H flag is set to 1, and the new carry is reset (0).
            newF |= CAPI.ARCH.H_FLAG;
        } else {
            // If the old carry was reset (0), the H flag is reset (0), and the new carry is set (1).
            newF |= CAPI.ARCH.C_FLAG;
        }

        // The N flag is reset.
        registers.F = newF;

    - name: or
      template: standard
      nwords: 2
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xF6"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        // Performs a bitwise logical OR between the accumulator and the immediate value n.
        registers.A = registers.A | n;
        // H, N, and C flags are reset. S, Z, and P/V are set based on the result.
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);

    - name: ld
      template: ED
      nwords: 4
      fields:
        - field: opcode2
          value: "0x43"
        - field: instructionFormatting
          type: skip
          value: "bc,"
          order: 2
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 1
      definition: |
        // Stores BC into the memory location pointed to by nn.
        CAPI.MEM.write(nn, 1, registers.C);
        CAPI.MEM.write(nn + 1n, 1, registers.B);

    - name: ld
      template: ED
      nwords: 4
      fields:
        - field: opcode2
          value: "0x53"
        - field: instructionFormatting
          type: skip
          value: "de,"
          order: 2
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 1
      definition: |
        // Stores DE into the memory location pointed to by nn.
        CAPI.MEM.write(nn, 1, registers.E);
        CAPI.MEM.write(nn + 1n, 1, registers.D);

    - name: ld
      template: ED
      nwords: 4
      fields:
        - field: opcode2
          value: "0x63"
        - field: instructionFormatting
          type: skip
          value: "de,"
          order: 2
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 1
      definition: |
        // Stores HL into the memory location pointed to by nn.
        CAPI.MEM.write(nn, 1, registers.L);
        CAPI.MEM.write(nn + 1n, 1, registers.H);

    - name: ld
      template: ED
      nwords: 4
      fields:
        - field: opcode2
          value: "0x73"
        - field: instructionFormatting
          type: skip
          value: "sp,"
          order: 2
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 1
      definition: |
        // Stores SP into the memory location pointed to by nn.
        CAPI.MEM.write(nn, 2, registers.SP);

    - name: ld
      template: ED
      nwords: 4
      fields:
        - field: opcode2
          value: "0x4B"
        - field: instructionFormatting
          type: skip
          value: "bc,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 2
      definition: |
        registers.C = CAPI.MEM.read(nn, 1);
        registers.B = CAPI.MEM.read(nn + 1n, 1);

    - name: in
      template: ED
      nwords: 2
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x78"
        - field: port
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        // A byte from the port at the 16-bit address contained in the BC register pair is written to A.
        registers.A = CAPI.ARCH.read((registers.B << 8n) | registers.C);

    - name: scf
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0x37"
      definition: |
        // Sets Carry flag. Clears N and H. Preserves S, Z, P/V.
        // S(bit 7), Z(bit 6), P/V(bit 2) are preserved.
        // N(bit 1) and H(bit 4) are cleared. C(bit 0) is set.
        const preservedFlags = registers.F & 0xC4n; // Mask for S, Z, P/V
        registers.F = preservedFlags | 0x01n;      // Set C flag

    - name: ret
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xC0"
        - field: instructionFormatting
          type: skip
          value: "nz"
          order: 1
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) === 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: pop bc
      template: standard
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xC1"
      definition: |
        registers.C = CAPI.MEM.read(registers.SP, 1);
        registers.B = CAPI.MEM.read(registers.SP + 1n, 1);
        registers.SP = (registers.SP + 2n) & 0xFFFFn;
    - name: push bc
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xC5"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.B);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.C);

    - name: rst 00h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xC7"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        registers.PC = 0x00n;
    - name: ret
      template: standard
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xC9"
      definition: |
        const lsb = CAPI.MEM.read(registers.SP, 1);
        const msb = CAPI.MEM.read(registers.SP + 1n, 1);
        registers.PC = (msb << 8n) | lsb;
        registers.SP = (registers.SP + 2n) & 0xFFFFn;
    - name: ret
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xC8"
        - field: instructionFormatting
          type: skip
          value: "z"
          order: 1
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) !== 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: call # nz
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xC4"
        - field: instructionFormatting
          type: skip
          value: "nz,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) === 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }
    - name: call # z
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xCC"
        - field: instructionFormatting
          type: skip
          value: "z,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.Z_FLAG) !== 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }
    - name: call
      template: standard
      nwords: 3
      clk_cycles: 17
      fields:
        - field: opcode
          value: "0xCD"
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 1
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        registers.PC = nn;
    - name: rst 08h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xCF"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        registers.PC = 0x08n;
    - name: ret nc
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xD0"
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) === 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: pop de
      template: standard
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xD1"
      definition: |
        registers.E = CAPI.MEM.read(registers.SP, 1);
        registers.D = CAPI.MEM.read(registers.SP + 1n, 1);
        registers.SP = (registers.SP + 2n) & 0xFFFFn;
    - name: call # nc,
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xD4"
        - field: instructionFormatting
          type: skip
          value: "nc,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) === 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }
    - name: push de
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xD5"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.D);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.E);
    - name: ret c
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xD8"
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) !== 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: call # c,
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xDC"
        - field: instructionFormatting
          type: skip
          value: "c,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.C_FLAG) !== 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }

    - name: exx
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0xD9"
      definition: |
        // Exchanges the contents of the BC, DE, and HL register pairs 
        // with the contents of BC', DE', and HL'.
        // to variables with a "_prime" suffix (e.g., B_prime).
        let temp_reg;
        temp_reg = registers.B;
        registers.B = registers.B_prime;
        registers.B_prime = temp_reg;

        temp_reg = registers.C;
        registers.C = registers.C_prime;
        registers.C_prime = temp_reg;

        temp_reg = registers.D;
        registers.D = registers.D_prime;
        registers.D_prime = temp_reg;

        temp_reg = registers.E;
        registers.E = registers.E_prime;
        registers.E_prime = temp_reg;

        temp_reg = registers.H;
        registers.H = registers.H_prime;
        registers.H_prime = temp_reg;

        temp_reg = registers.L;
        registers.L = registers.L_prime;
        registers.L_prime = temp_reg;

    - name: rst 18h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xDF"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        registers.PC = 0x18n;
    - name: ret po
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xE0"
      definition: |
        if ((registers.F & CAPI.ARCH.PV_FLAG) === 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: pop hl
      template: standard
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xE1"
      definition: |
        registers.L = CAPI.MEM.read(registers.SP, 1);
        registers.H = CAPI.MEM.read(registers.SP + 1n, 1);
        registers.SP = (registers.SP + 2n) & 0xFFFFn;
    - name: call # po,
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xE4"
        - field: instructionFormatting
          type: skip
          value: "po,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.PV_FLAG) === 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }
    - name: push hl
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xE5"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.H);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.L);
    - name: ret pe
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xE8"
      definition: |
        if ((registers.F & CAPI.ARCH.PV_FLAG) !== 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: call # pe,
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xEC"
        - field: instructionFormatting
          type: skip
          value: "pe,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.PV_FLAG) !== 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }

    - name: xor
      template: standard
      nwords: 2
      clk_cycles: 7
      fields:
        - field: opcode
          value: "0xEE"
        - field: n
          type: imm-unsigned
          startbit: 15
          stopbit: 8
          order: 1
      definition: |
        // Performs a bitwise logical XOR between the accumulator and the immediate value n.
        registers.A = registers.A ^ n;
        // H, N, and C flags are reset. S, Z, and P/V are set based on the result.
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);

    - name: rst 28h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xEF"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        registers.PC = 0x28n;
    - name: ret p
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xF0"
      definition: |
        if ((registers.F & CAPI.ARCH.S_FLAG) === 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: pop af
      template: standard
      clk_cycles: 10
      fields:
        - field: opcode
          value: "0xF1"
      definition: |
        registers.F = CAPI.MEM.read(registers.SP, 1);
        registers.A = CAPI.MEM.read(registers.SP + 1n, 1);
        registers.SP = (registers.SP + 2n) & 0xFFFFn;
    - name: call # p,
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xF4"
        - field: instructionFormatting
          type: skip
          value: "p,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.S_FLAG) === 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }
    - name: push af
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xF5"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.A);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.F);
    - name: ei
      template: standard
      nwords: 1
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0xFB"
      definition: |
        registers['IFF1'] = 1n;
        registers['IFF2'] = 1n;
    - name: ret m
      template: standard
      clk_cycles: 11 # 5 if not taken
      fields:
        - field: opcode
          value: "0xF8"
      definition: |
        if ((registers.F & CAPI.ARCH.S_FLAG) !== 0n) {
            const lsb = CAPI.MEM.read(registers.SP, 1);
            const msb = CAPI.MEM.read(registers.SP + 1n, 1);
            registers.PC = (msb << 8n) | lsb;
            registers.SP = (registers.SP + 2n) & 0xFFFFn;
        }
    - name: ld sp, hl
      template: standard
      clk_cycles: 6
      fields:
        - field: opcode
          value: "0xF9"
      definition: |
        registers.SP = (registers.H << 8n) | registers.L;
    - name: call # m,
      template: standard
      nwords: 3
      clk_cycles: 17 # 10 if not taken
      fields:
        - field: opcode
          value: "0xFC"
        - field: instructionFormatting
          type: skip
          value: "m,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 23
          stopbit: 8
          order: 2
      definition: |
        if ((registers.F & CAPI.ARCH.S_FLAG) !== 0n) {
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
            registers.SP = (registers.SP - 1n) & 0xFFFFn;
            CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
            registers.PC = nn;
        }
    - name: di
      template: standard
      clk_cycles: 4
      fields:
        - field: opcode
          value: "0xF3"
      definition: |
        registers['IFF1'] = 0n;
        registers['IFF2'] = 0n;

    - name: rst 38h
      template: standard
      clk_cycles: 11
      fields:
        - field: opcode
          value: "0xFF"
      definition: |
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, (registers.PC >> 8n) & 0xFFn);
        registers.SP = (registers.SP - 1n) & 0xFFFFn;
        CAPI.MEM.write(registers.SP, 1, registers.PC & 0xFFn);
        registers.PC = 0x38n;

    # RLC r
    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x00"
        - field: instructionFormatting
          type: skip
          value: "b"
          order: 1
      definition: |
        const msb = (registers.B & 0x80n) >> 7n;
        registers.B = ((registers.B << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.B, msb);

    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x01"
        - field: instructionFormatting
          type: skip
          value: "c"
          order: 1
      definition: |
        const msb = (registers.C & 0x80n) >> 7n;
        registers.C = ((registers.C << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.C, msb);

    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x02"
        - field: instructionFormatting
          type: skip
          value: "d"
          order: 1
      definition: |
        const msb = (registers.D & 0x80n) >> 7n;
        registers.D = ((registers.D << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.D, msb);

    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x03"
        - field: instructionFormatting
          type: skip
          value: "e"
          order: 1
      definition: |
        const msb = (registers.E & 0x80n) >> 7n;
        registers.E = ((registers.E << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.E, msb);

    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x04"
        - field: instructionFormatting
          type: skip
          value: "h"
          order: 1
      definition: |
        const msb = (registers.H & 0x80n) >> 7n;
        registers.H = ((registers.H << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.H, msb);

    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x05"
        - field: instructionFormatting
          type: skip
          value: "l"
          order: 1
      definition: |
        const msb = (registers.L & 0x80n) >> 7n;
        registers.L = ((registers.L << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.L, msb);

    - name: rlc
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x07"
        - field: instructionFormatting
          type: skip
          value: "a"
          order: 1
      definition: |
        const msb = (registers.A & 0x80n) >> 7n;
        registers.A = ((registers.A << 1n) | msb) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(registers.A, msb);

    # RLC (HL)
    - name: rlc
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x06"
        - field: instructionFormatting
          type: skip
          value: "(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        const msb = (value & 0x80n) >> 7n;
        const result = ((value << 1n) | msb) & 0xFFn;
        CAPI.MEM.write(addr, 1, result);
        registers.F = CAPI.ARCH.calculateFlags_ROTATE(result, msb);

    # SRL r
    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x38"
        - field: instructionFormatting
          type: skip
          value: "b"
          order: 1
      definition: |
        const lsb = registers.B & 0x01n;
        registers.B = registers.B >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.B, lsb);

    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x39"
        - field: instructionFormatting
          type: skip
          value: "c"
          order: 1
      definition: |
        const lsb = registers.C & 0x01n;
        registers.C = registers.C >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.C, lsb);

    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x3A"
        - field: instructionFormatting
          type: skip
          value: "d"
          order: 1
      definition: |
        const lsb = registers.D & 0x01n;
        registers.D = registers.D >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.D, lsb);

    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x3B"
        - field: instructionFormatting
          type: skip
          value: "e"
          order: 1
      definition: |
        const lsb = registers.E & 0x01n;
        registers.E = registers.E >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.E, lsb);

    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x3C"
        - field: instructionFormatting
          type: skip
          value: "h"
          order: 1
      definition: |
        const lsb = registers.H & 0x01n;
        registers.H = registers.H >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.H, lsb);

    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x3D"
        - field: instructionFormatting
          type: skip
          value: "l"
          order: 1
      definition: |
        const lsb = registers.L & 0x01n;
        registers.L = registers.L >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.L, lsb);

    - name: srl
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x3F"
        - field: instructionFormatting
          type: skip
          value: "a"
          order: 1
      definition: |
        const lsb = registers.A & 0x01n;
        registers.A = registers.A >> 1n;
        registers.F = CAPI.ARCH.calculateFlags_SRL(registers.A, lsb);

    # SRL (HL)
    - name: srl
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x3E"
        - field: instructionFormatting
          type: skip
          value: "(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        const lsb = value & 0x01n;
        const result = value >> 1n;
        CAPI.MEM.write(addr, 1, result);
        registers.F = CAPI.ARCH.calculateFlags_SRL(result, lsb);

    - name: ld
      template: DD
      clk_cycles: 14
      nwords: 4
      fields:
        - field: opcode2
          value: "0x21"
        - field: instructionFormatting
          type: skip
          value: "ix,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          order: 2
      definition: |
        // Loads nn into register IX.
        registers.IX = nn;

    - name: add
      template: DD
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x09"
        - field: instructionFormatting
          type: skip
          value: "ix, bc"
          order: 1
      definition: |
        // The value of BC is added to IX.
        const value = (((registers.B << 8n) | registers.C) - 1n) & 0xFFFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADD16(registers.IX, value, registers.F);
        registers.IX = (registers.IX + value) & 0xFFFFn;

    - name: add
      template: DD
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x29"
        - field: instructionFormatting
          type: skip
          value: "ix, ix"
          order: 1
      definition: |
        // The value of IX is added to IX.
        let prevIX = registers.IX;
        registers.IX = (registers.IX + registers.IX) & 0xFFFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADD16(prevIX, prevIX, registers.F)

    - name: jp
      template: DD
      nwords: 2
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE9"
        - field: instructionFormatting
          type: skip
          value: "(ix)"
          order: 1
      definition: |
        registers.PC = registers.IX;

    # SRL (IX+d)
    - name: srl
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x3E"
        - field: imm
          order: 2
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        const lsb = value & 0x01n;
        const result = value >> 1n;
        CAPI.MEM.write(addr, 1, result);
        registers.F = CAPI.ARCH.calculateFlags_SRL(result, lsb);

    # SRL (IY+d)
    - name: srl
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x3E"
        - field: d
          order: 2
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        const lsb = value & 0x01n;
        const result = value >> 1n;
        CAPI.MEM.write(addr, 1, result);
        registers.F = CAPI.ARCH.calculateFlags_SRL(result, lsb);

    # BIT b, r instructions
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x40"
        - field: instructionFormatting
          type: skip
          value: "0,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x41"
        - field: instructionFormatting
          type: skip
          value: "0,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x42"
        - field: instructionFormatting
          type: skip
          value: "0,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x43"
        - field: instructionFormatting
          type: skip
          value: "0,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x44"
        - field: instructionFormatting
          type: skip
          value: "0,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x45"
        - field: instructionFormatting
          type: skip
          value: "0,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x47"
        - field: instructionFormatting
          type: skip
          value: "0,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x48"
        - field: instructionFormatting
          type: skip
          value: "1,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x49"
        - field: instructionFormatting
          type: skip
          value: "1,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x4A"
        - field: instructionFormatting
          type: skip
          value: "1,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x4B"
        - field: instructionFormatting
          type: skip
          value: "1,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x4C"
        - field: instructionFormatting
          type: skip
          value: "1,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x4D"
        - field: instructionFormatting
          type: skip
          value: "1,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x4F"
        - field: instructionFormatting
          type: skip
          value: "1,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x50"
        - field: instructionFormatting
          type: skip
          value: "2,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x51"
        - field: instructionFormatting
          type: skip
          value: "2,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x52"
        - field: instructionFormatting
          type: skip
          value: "2,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x53"
        - field: instructionFormatting
          type: skip
          value: "2,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x54"
        - field: instructionFormatting
          type: skip
          value: "2,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x55"
        - field: instructionFormatting
          type: skip
          value: "2,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x57"
        - field: instructionFormatting
          type: skip
          value: "2,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x58"
        - field: instructionFormatting
          type: skip
          value: "3,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x59"
        - field: instructionFormatting
          type: skip
          value: "3,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x5A"
        - field: instructionFormatting
          type: skip
          value: "3,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x5B"
        - field: instructionFormatting
          type: skip
          value: "3,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x5C"
        - field: instructionFormatting
          type: skip
          value: "3,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x5D"
        - field: instructionFormatting
          type: skip
          value: "3,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x5F"
        - field: instructionFormatting
          type: skip
          value: "3,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x60"
        - field: instructionFormatting
          type: skip
          value: "4,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x61"
        - field: instructionFormatting
          type: skip
          value: "4,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x62"
        - field: instructionFormatting
          type: skip
          value: "4,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x63"
        - field: instructionFormatting
          type: skip
          value: "4,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x64"
        - field: instructionFormatting
          type: skip
          value: "4,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x65"
        - field: instructionFormatting
          type: skip
          value: "4,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x67"
        - field: instructionFormatting
          type: skip
          value: "4,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x68"
        - field: instructionFormatting
          type: skip
          value: "5,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x69"
        - field: instructionFormatting
          type: skip
          value: "5,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x6A"
        - field: instructionFormatting
          type: skip
          value: "5,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x6B"
        - field: instructionFormatting
          type: skip
          value: "5,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x6C"
        - field: instructionFormatting
          type: skip
          value: "5,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x6D"
        - field: instructionFormatting
          type: skip
          value: "5,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x6F"
        - field: instructionFormatting
          type: skip
          value: "5,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x70"
        - field: instructionFormatting
          type: skip
          value: "6,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x71"
        - field: instructionFormatting
          type: skip
          value: "6,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x72"
        - field: instructionFormatting
          type: skip
          value: "6,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x73"
        - field: instructionFormatting
          type: skip
          value: "6,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x74"
        - field: instructionFormatting
          type: skip
          value: "6,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x75"
        - field: instructionFormatting
          type: skip
          value: "6,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x77"
        - field: instructionFormatting
          type: skip
          value: "6,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x78"
        - field: instructionFormatting
          type: skip
          value: "7,b"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.B, 7, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x79"
        - field: instructionFormatting
          type: skip
          value: "7,c"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.C, 7, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x7A"
        - field: instructionFormatting
          type: skip
          value: "7,d"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.D, 7, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x7B"
        - field: instructionFormatting
          type: skip
          value: "7,e"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.E, 7, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x7C"
        - field: instructionFormatting
          type: skip
          value: "7,h"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.H, 7, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x7D"
        - field: instructionFormatting
          type: skip
          value: "7,l"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.L, 7, registers.F);
    - name: bit
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x7F"
        - field: instructionFormatting
          type: skip
          value: "7,a"
          order: 1
      definition: registers.F = CAPI.ARCH.calculateFlags_BIT(registers.A, 7, registers.F);

    # BIT b, (HL)
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x46"
        - field: instructionFormatting
          type: skip
          value: "0,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 0, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x4E"
        - field: instructionFormatting
          type: skip
          value: "1,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 1, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x56"
        - field: instructionFormatting
          type: skip
          value: "2,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 2, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x5E"
        - field: instructionFormatting
          type: skip
          value: "3,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 3, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x66"
        - field: instructionFormatting
          type: skip
          value: "4,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 4, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x6E"
        - field: instructionFormatting
          type: skip
          value: "5,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 5, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x76"
        - field: instructionFormatting
          type: skip
          value: "6,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 6, registers.F);
    - name: bit
      template: CB
      clk_cycles: 12
      fields:
        - field: opcode2
          value: "0x7E"
        - field: instructionFormatting
          type: skip
          value: "7,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 7, registers.F);

    # SET b, (HL)
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xC6"
        - field: instructionFormatting
          type: skip
          value: "0,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x01n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xCE"
        - field: instructionFormatting
          type: skip
          value: "1,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x02n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xD6"
        - field: instructionFormatting
          type: skip
          value: "2,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x04n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xDE"
        - field: instructionFormatting
          type: skip
          value: "3,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x08n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xE6"
        - field: instructionFormatting
          type: skip
          value: "4,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x10n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xEE"
        - field: instructionFormatting
          type: skip
          value: "5,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x20n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xF6"
        - field: instructionFormatting
          type: skip
          value: "6,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x40n);
    - name: set
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xFE"
        - field: instructionFormatting
          type: skip
          value: "7,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x80n);

    # RES b, (HL)
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x86"
        - field: instructionFormatting
          type: skip
          value: "0,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x01n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x8E"
        - field: instructionFormatting
          type: skip
          value: "1,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x02n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x96"
        - field: instructionFormatting
          type: skip
          value: "2,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x04n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x9E"
        - field: instructionFormatting
          type: skip
          value: "3,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x08n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xA6"
        - field: instructionFormatting
          type: skip
          value: "4,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x10n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xAE"
        - field: instructionFormatting
          type: skip
          value: "5,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x20n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xB6"
        - field: instructionFormatting
          type: skip
          value: "6,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x40n);
    - name: res
      template: CB
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0xBE"
        - field: instructionFormatting
          type: skip
          value: "7,(hl)"
          order: 1
      definition: |
        const addr = (registers.H << 8n) | registers.L;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x80n);

    # BIT b, (IX+d)
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x46"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "0,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 0, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x4E"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "1,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 1, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x56"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "2,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 2, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x5E"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "3,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 3, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x66"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "4,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 4, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x6E"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "5,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 5, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x76"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "6,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 6, registers.F);
    - name: bit
      template: DDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x7E"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "7,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 7, registers.F);

    # BIT b, (IY+d)
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x46"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "0,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 0, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x4E"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "1,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 1, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x56"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "2,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 2, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x5E"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "3,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 3, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x66"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "4,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 4, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x6E"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "5,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 5, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x76"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "6,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 6, registers.F);
    - name: bit
      template: FDCB
      clk_cycles: 20
      fields:
        - field: opcode3
          value: "0x7E"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "7,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.F = CAPI.ARCH.calculateFlags_BIT(value, 7, registers.F);

    # SET b, (IX+d)
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xC6"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "0,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x01n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xCE"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "1,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x02n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xD6"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "2,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x04n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xDE"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "3,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x08n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xE6"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "4,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x10n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xEE"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "5,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x20n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xF6"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "6,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x40n);
    - name: set
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xFE"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "7,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x80n);

    # RES b, (IX+d)
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x86"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "0,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x01n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x8E"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "1,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x02n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x96"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "2,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x04n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x9E"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "3,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x08n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xA6"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "4,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x10n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xAE"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "5,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x20n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xB6"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "6,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x40n);
    - name: res
      template: DDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xBE"
        - field: imm
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "7,(ix+"
          order: 1
      definition: |
        const addr = (registers.IX + imm) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x80n);

    # SET b, r
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC0"
        - field: instructionFormatting
          type: skip
          value: "0,b"
          order: 1
      definition: registers.B |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC1"
        - field: instructionFormatting
          type: skip
          value: "0,c"
          order: 1
      definition: registers.C |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC2"
        - field: instructionFormatting
          type: skip
          value: "0,d"
          order: 1
      definition: registers.D |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC3"
        - field: instructionFormatting
          type: skip
          value: "0,e"
          order: 1
      definition: registers.E |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC4"
        - field: instructionFormatting
          type: skip
          value: "0,h"
          order: 1
      definition: registers.H |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC5"
        - field: instructionFormatting
          type: skip
          value: "0,l"
          order: 1
      definition: registers.L |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC7"
        - field: instructionFormatting
          type: skip
          value: "0,a"
          order: 1
      definition: registers.A |= 0x01n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC8"
        - field: instructionFormatting
          type: skip
          value: "1,b"
          order: 1
      definition: registers.B |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xC9"
        - field: instructionFormatting
          type: skip
          value: "1,c"
          order: 1
      definition: registers.C |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xCA"
        - field: instructionFormatting
          type: skip
          value: "1,d"
          order: 1
      definition: registers.D |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xCB"
        - field: instructionFormatting
          type: skip
          value: "1,e"
          order: 1
      definition: registers.E |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xCC"
        - field: instructionFormatting
          type: skip
          value: "1,h"
          order: 1
      definition: registers.H |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xCD"
        - field: instructionFormatting
          type: skip
          value: "1,l"
          order: 1
      definition: registers.L |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xCF"
        - field: instructionFormatting
          type: skip
          value: "1,a"
          order: 1
      definition: registers.A |= 0x02n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD0"
        - field: instructionFormatting
          type: skip
          value: "2,b"
          order: 1
      definition: registers.B |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD1"
        - field: instructionFormatting
          type: skip
          value: "2,c"
          order: 1
      definition: registers.C |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD2"
        - field: instructionFormatting
          type: skip
          value: "2,d"
          order: 1
      definition: registers.D |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD3"
        - field: instructionFormatting
          type: skip
          value: "2,e"
          order: 1
      definition: registers.E |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD4"
        - field: instructionFormatting
          type: skip
          value: "2,h"
          order: 1
      definition: registers.H |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD5"
        - field: instructionFormatting
          type: skip
          value: "2,l"
          order: 1
      definition: registers.L |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD7"
        - field: instructionFormatting
          type: skip
          value: "2,a"
          order: 1
      definition: registers.A |= 0x04n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD8"
        - field: instructionFormatting
          type: skip
          value: "3,b"
          order: 1
      definition: registers.B |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xD9"
        - field: instructionFormatting
          type: skip
          value: "3,c"
          order: 1
      definition: registers.C |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xDA"
        - field: instructionFormatting
          type: skip
          value: "3,d"
          order: 1
      definition: registers.D |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xDB"
        - field: instructionFormatting
          type: skip
          value: "3,e"
          order: 1
      definition: registers.E |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xDC"
        - field: instructionFormatting
          type: skip
          value: "3,h"
          order: 1
      definition: registers.H |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xDD"
        - field: instructionFormatting
          type: skip
          value: "3,l"
          order: 1
      definition: registers.L |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xDF"
        - field: instructionFormatting
          type: skip
          value: "3,a"
          order: 1
      definition: registers.A |= 0x08n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE0"
        - field: instructionFormatting
          type: skip
          value: "4,b"
          order: 1
      definition: registers.B |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE1"
        - field: instructionFormatting
          type: skip
          value: "4,c"
          order: 1
      definition: registers.C |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE2"
        - field: instructionFormatting
          type: skip
          value: "4,d"
          order: 1
      definition: registers.D |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE3"
        - field: instructionFormatting
          type: skip
          value: "4,e"
          order: 1
      definition: registers.E |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE4"
        - field: instructionFormatting
          type: skip
          value: "4,h"
          order: 1
      definition: registers.H |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE5"
        - field: instructionFormatting
          type: skip
          value: "4,l"
          order: 1
      definition: registers.L |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE7"
        - field: instructionFormatting
          type: skip
          value: "4,a"
          order: 1
      definition: registers.A |= 0x10n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE8"
        - field: instructionFormatting
          type: skip
          value: "5,b"
          order: 1
      definition: registers.B |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xE9"
        - field: instructionFormatting
          type: skip
          value: "5,c"
          order: 1
      definition: registers.C |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xEA"
        - field: instructionFormatting
          type: skip
          value: "5,d"
          order: 1
      definition: registers.D |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xEB"
        - field: instructionFormatting
          type: skip
          value: "5,e"
          order: 1
      definition: registers.E |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xEC"
        - field: instructionFormatting
          type: skip
          value: "5,h"
          order: 1
      definition: registers.H |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xED"
        - field: instructionFormatting
          type: skip
          value: "5,l"
          order: 1
      definition: registers.L |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xEF"
        - field: instructionFormatting
          type: skip
          value: "5,a"
          order: 1
      definition: registers.A |= 0x20n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF0"
        - field: instructionFormatting
          type: skip
          value: "6,b"
          order: 1
      definition: registers.B |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF1"
        - field: instructionFormatting
          type: skip
          value: "6,c"
          order: 1
      definition: registers.C |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF2"
        - field: instructionFormatting
          type: skip
          value: "6,d"
          order: 1
      definition: registers.D |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF3"
        - field: instructionFormatting
          type: skip
          value: "6,e"
          order: 1
      definition: registers.E |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF4"
        - field: instructionFormatting
          type: skip
          value: "6,h"
          order: 1
      definition: registers.H |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF5"
        - field: instructionFormatting
          type: skip
          value: "6,l"
          order: 1
      definition: registers.L |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF7"
        - field: instructionFormatting
          type: skip
          value: "6,a"
          order: 1
      definition: registers.A |= 0x40n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF8"
        - field: instructionFormatting
          type: skip
          value: "7,b"
          order: 1
      definition: registers.B |= 0x80n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xF9"
        - field: instructionFormatting
          type: skip
          value: "7,c"
          order: 1
      definition: registers.C |= 0x80n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xFA"
        - field: instructionFormatting
          type: skip
          value: "7,d"
          order: 1
      definition: registers.D |= 0x80n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xFB"
        - field: instructionFormatting
          type: skip
          value: "7,e"
          order: 1
      definition: registers.E |= 0x80n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xFC"
        - field: instructionFormatting
          type: skip
          value: "7,h"
          order: 1
      definition: registers.H |= 0x80n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xFD"
        - field: instructionFormatting
          type: skip
          value: "7,l"
          order: 1
      definition: registers.L |= 0x80n;
    - name: set
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xFF"
        - field: instructionFormatting
          type: skip
          value: "7,a"
          order: 1
      definition: registers.A |= 0x80n;

    # RES b, r
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x80"
        - field: instructionFormatting
          type: skip
          value: "0,b"
          order: 1
      definition: registers.B &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x81"
        - field: instructionFormatting
          type: skip
          value: "0,c"
          order: 1
      definition: registers.C &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x82"
        - field: instructionFormatting
          type: skip
          value: "0,d"
          order: 1
      definition: registers.D &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x83"
        - field: instructionFormatting
          type: skip
          value: "0,e"
          order: 1
      definition: registers.E &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x84"
        - field: instructionFormatting
          type: skip
          value: "0,h"
          order: 1
      definition: registers.H &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x85"
        - field: instructionFormatting
          type: skip
          value: "0,l"
          order: 1
      definition: registers.L &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x87"
        - field: instructionFormatting
          type: skip
          value: "0,a"
          order: 1
      definition: registers.A &= ~0x01n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x88"
        - field: instructionFormatting
          type: skip
          value: "1,b"
          order: 1
      definition: registers.B &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x89"
        - field: instructionFormatting
          type: skip
          value: "1,c"
          order: 1
      definition: registers.C &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x8A"
        - field: instructionFormatting
          type: skip
          value: "1,d"
          order: 1
      definition: registers.D &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x8B"
        - field: instructionFormatting
          type: skip
          value: "1,e"
          order: 1
      definition: registers.E &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x8C"
        - field: instructionFormatting
          type: skip
          value: "1,h"
          order: 1
      definition: registers.H &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x8D"
        - field: instructionFormatting
          type: skip
          value: "1,l"
          order: 1
      definition: registers.L &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x8F"
        - field: instructionFormatting
          type: skip
          value: "1,a"
          order: 1
      definition: registers.A &= ~0x02n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x90"
        - field: instructionFormatting
          type: skip
          value: "2,b"
          order: 1
      definition: registers.B &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x91"
        - field: instructionFormatting
          type: skip
          value: "2,c"
          order: 1
      definition: registers.C &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x92"
        - field: instructionFormatting
          type: skip
          value: "2,d"
          order: 1
      definition: registers.D &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x93"
        - field: instructionFormatting
          type: skip
          value: "2,e"
          order: 1
      definition: registers.E &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x94"
        - field: instructionFormatting
          type: skip
          value: "2,h"
          order: 1
      definition: registers.H &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x95"
        - field: instructionFormatting
          type: skip
          value: "2,l"
          order: 1
      definition: registers.L &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x97"
        - field: instructionFormatting
          type: skip
          value: "2,a"
          order: 1
      definition: registers.A &= ~0x04n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x98"
        - field: instructionFormatting
          type: skip
          value: "3,b"
          order: 1
      definition: registers.B &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x99"
        - field: instructionFormatting
          type: skip
          value: "3,c"
          order: 1
      definition: registers.C &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x9A"
        - field: instructionFormatting
          type: skip
          value: "3,d"
          order: 1
      definition: registers.D &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x9B"
        - field: instructionFormatting
          type: skip
          value: "3,e"
          order: 1
      definition: registers.E &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x9C"
        - field: instructionFormatting
          type: skip
          value: "3,h"
          order: 1
      definition: registers.H &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x9D"
        - field: instructionFormatting
          type: skip
          value: "3,l"
          order: 1
      definition: registers.L &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x9F"
        - field: instructionFormatting
          type: skip
          value: "3,a"
          order: 1
      definition: registers.A &= ~0x08n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA0"
        - field: instructionFormatting
          type: skip
          value: "4,b"
          order: 1
      definition: registers.B &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA1"
        - field: instructionFormatting
          type: skip
          value: "4,c"
          order: 1
      definition: registers.C &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA2"
        - field: instructionFormatting
          type: skip
          value: "4,d"
          order: 1
      definition: registers.D &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA3"
        - field: instructionFormatting
          type: skip
          value: "4,e"
          order: 1
      definition: registers.E &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA4"
        - field: instructionFormatting
          type: skip
          value: "4,h"
          order: 1
      definition: registers.H &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA5"
        - field: instructionFormatting
          type: skip
          value: "4,l"
          order: 1
      definition: registers.L &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA7"
        - field: instructionFormatting
          type: skip
          value: "4,a"
          order: 1
      definition: registers.A &= ~0x10n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA8"
        - field: instructionFormatting
          type: skip
          value: "5,b"
          order: 1
      definition: registers.B &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xA9"
        - field: instructionFormatting
          type: skip
          value: "5,c"
          order: 1
      definition: registers.C &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xAA"
        - field: instructionFormatting
          type: skip
          value: "5,d"
          order: 1
      definition: registers.D &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xAB"
        - field: instructionFormatting
          type: skip
          value: "5,e"
          order: 1
      definition: registers.E &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xAC"
        - field: instructionFormatting
          type: skip
          value: "5,h"
          order: 1
      definition: registers.H &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xAD"
        - field: instructionFormatting
          type: skip
          value: "5,l"
          order: 1
      definition: registers.L &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xAF"
        - field: instructionFormatting
          type: skip
          value: "5,a"
          order: 1
      definition: registers.A &= ~0x20n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB0"
        - field: instructionFormatting
          type: skip
          value: "6,b"
          order: 1
      definition: registers.B &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB1"
        - field: instructionFormatting
          type: skip
          value: "6,c"
          order: 1
      definition: registers.C &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB2"
        - field: instructionFormatting
          type: skip
          value: "6,d"
          order: 1
      definition: registers.D &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB3"
        - field: instructionFormatting
          type: skip
          value: "6,e"
          order: 1
      definition: registers.E &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB4"
        - field: instructionFormatting
          type: skip
          value: "6,h"
          order: 1
      definition: registers.H &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB5"
        - field: instructionFormatting
          type: skip
          value: "6,l"
          order: 1
      definition: registers.L &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB7"
        - field: instructionFormatting
          type: skip
          value: "6,a"
          order: 1
      definition: registers.A &= ~0x40n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB8"
        - field: instructionFormatting
          type: skip
          value: "7,b"
          order: 1
      definition: registers.B &= ~0x80n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xB9"
        - field: instructionFormatting
          type: skip
          value: "7,c"
          order: 1
      definition: registers.C &= ~0x80n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xBA"
        - field: instructionFormatting
          type: skip
          value: "7,d"
          order: 1
      definition: registers.D &= ~0x80n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xBB"
        - field: instructionFormatting
          type: skip
          value: "7,e"
          order: 1
      definition: registers.E &= ~0x80n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xBC"
        - field: instructionFormatting
          type: skip
          value: "7,h"
          order: 1
      definition: registers.H &= ~0x80n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xBD"
        - field: instructionFormatting
          type: skip
          value: "7,l"
          order: 1
      definition: registers.L &= ~0x80n;
    - name: res
      template: CB
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0xBF"
        - field: instructionFormatting
          type: skip
          value: "7,a"
          order: 1
      definition: registers.A &= ~0x80n;

    - name: neg
      template: ED
      nwords: 2
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x44"
      definition: |
        // The contents of A are negated (two's complement).
        // This is equivalent to 0 - A.
        const oldValueA = registers.A;
        registers.A = (0n - oldValueA) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SUB(0n, oldValueA);

    - name: ld
      template: ED
      nwords: 2
      clk_cycles: 9
      fields:
        - field: opcode2
          value: "0x47"
        - field: instructionFormatting
          type: skip # This is ONLY for visualization purposes, it is not a real field
          value: "i, a"
          order: 2
      definition: |
        // Loads the value of A into the I register.
        registers.I = registers.A;

    - name: ld
      template: ED
      nwords: 4
      clk_cycles: 20
      fields:
        - field: opcode2
          value: "0x5B"
        - field: instructionFormatting
          type: skip
          value: "de,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 2
      definition: |
        // Loads the value pointed to by nn into DE.
        registers.E = CAPI.MEM.read(nn, 1);
        registers.D = CAPI.MEM.read(nn + 1n, 1);

    - name: ld
      template: ED
      nwords: 4
      clk_cycles: 20
      fields:
        - field: opcode2
          value: "0x6B"
        - field: instructionFormatting
          type: skip
          value: "hl,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 2
      definition: |
        // Loads the value pointed to by nn into HL.
        registers.L = CAPI.MEM.read(nn, 1);
        registers.H = CAPI.MEM.read(nn + 1n, 1);

    - name: ld
      template: ED
      nwords: 4
      clk_cycles: 20
      fields:
        - field: opcode2
          value: "0x7B"
        - field: instructionFormatting
          type: skip
          value: "sp,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          prefix: "("
          suffix: ")"
          order: 2
      definition: |
        // Loads the value pointed to by nn into SP
        lowSP = CAPI.MEM.read(nn, 1);
        highSP = CAPI.MEM.read(nn + 1n, 1);
        registers.SP = (highSP << 8n) | lowSP;
    - name: lddr
      template: ED
      # Cycles: 21 if BC != 0, 16 if BC = 0. Handled in definition.
      fields:
        - field: opcode2
          value: "0xB8"
      definition: |
        // 1. Combine registers into 16-bit values
        const hlAddr = (registers.H << 8n) | registers.L;
        const deAddr = (registers.D << 8n) | registers.E;
        let bcCount = (registers.B << 8n) | registers.C;

        // 2. Perform the single-byte transfer. This happens even if bcCount is 1.
        const byteToCopy = CAPI.MEM.read(hlAddr, 1);
        CAPI.MEM.write(deAddr, 1, byteToCopy);

        // 3. Update registers
        const newHL = (hlAddr - 1n) & 0xFFFFn;
        const newDE = (deAddr - 1n) & 0xFFFFn;
        bcCount = (bcCount - 1n) & 0xFFFFn;

        registers.H = (newHL >> 8n) & 0xFFn;
        registers.L = newHL & 0xFFn;
        registers.D = (newDE >> 8n) & 0xFFn;
        registers.E = newDE & 0xFFn;
        registers.B = (bcCount >> 8n) & 0xFFn;
        registers.C = bcCount & 0xFFn;

        // 4. Update flags according to Z80 specification
        // S, Z, C are unaffected. H and N are reset. P/V is set if BC != 0.
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.C_FLAG);

        // 5. Check for repeat condition
        if (bcCount !== 0n) {
            newF |= CAPI.ARCH.PV_FLAG;
            // Rewind PC to re-execute this instruction
            registers.PC = (registers.PC - 2n) & 0xFFFFn;
            // set_private_field("clk_cycles", 21); // Optional: for accurate timing
        } else {
            // P/V is reset when BC becomes 0.
            // set_private_field("clk_cycles", 16); // Optional: for accurate timing
        }

        registers.F = newF;

    - name: ldir
      template: ED
      # Cycles: 21 if BC != 0, 16 if BC = 0. Handled in definition.
      fields:
        - field: opcode2
          value: "0xB0"
      definition: |
        // 1. Combine registers into 16-bit values
        const hlAddr = (registers.H << 8n) | registers.L;
        const deAddr = (registers.D << 8n) | registers.E;
        let bcCount = (registers.B << 8n) | registers.C;

        // 2. Perform the single-byte transfer. This happens even if bcCount is 1.
        const byteToCopy = CAPI.MEM.read(hlAddr, 1);
        CAPI.MEM.write(deAddr, 1, byteToCopy);

        // 3. Update registers
        const newHL = (hlAddr + 1n) & 0xFFFFn;
        const newDE = (deAddr + 1n) & 0xFFFFn;
        bcCount = (bcCount - 1n) & 0xFFFFn;

        registers.H = (newHL >> 8n) & 0xFFn;
        registers.L = newHL & 0xFFn;
        registers.D = (newDE >> 8n) & 0xFFn;
        registers.E = newDE & 0xFFn;
        registers.B = (bcCount >> 8n) & 0xFFn;
        registers.C = bcCount & 0xFFn;

        // 4. Update flags according to Z80 specification
        // S, Z, C are unaffected. H and N are reset. P/V is set if BC != 0.
        let newF = registers.F & (CAPI.ARCH.S_FLAG | CAPI.ARCH.Z_FLAG | CAPI.ARCH.C_FLAG); 

        // 5. Check for repeat condition
        if (bcCount !== 0n) {
            newF |= CAPI.ARCH.PV_FLAG;
            // Rewind PC to re-execute this instruction
            registers.PC = (registers.PC - 2n) & 0xFFFFn;
            // set_private_field("clk_cycles", 21); // Optional: for accurate timing
        } else {
            // P/V is reset when BC becomes 0.
            // set_private_field("clk_cycles", 16); // Optional: for accurate timing
        }

        registers.F = newF;

    - name: im
      template: ED
      nwords: 2
      clk_cycles: 8
      fields:
        - field: opcode2
          value: "0x56"
        - field: instructionFormatting
          type: skip
          value: "1"
          order: 1
      definition: |
        // Set the interrupt mode to 1 (stored in internal CPU state)
        if (typeof CAPI.ARCH.interruptMode === 'undefined') {
          CAPI.ARCH.interruptMode = 0;
        }
        CAPI.ARCH.interruptMode = 1;

    - name: reti
      template: ED
      nwords: 2
      clk_cycles: 14
      fields:
        - field: opcode2
          value: "0x4D"
      definition: |
        // Return from interrupt
        // Restore IFF1 from IFF2 (re-enable interrupts if they were enabled before)
        registers['IFF1'] = registers['IFF2'];
        // Pop return address from stack
        registers.PC = CAPI.MEM.read(registers.SP, 1) | (CAPI.MEM.read((registers.SP + 1n) & 0xFFFFn, 1) << 8n);
        registers.SP = (registers.SP + 2n) & 0xFFFFn;

    - name: ld
      template: FD
      nwords: 4
      fields:
        - field: opcode2
          value: "0x21"
        - field: instructionFormatting
          type: skip
          value: "iy,"
          order: 1
        - field: nn
          type: imm-unsigned
          startbit: 31
          stopbit: 16
          order: 2
      definition: |
        // Loads the 16-bit value nn into the IY register.
        // nn is a 16-bit unsigned integer.
        registers.IY = nn;

    - name: inc
      template: FD
      nwords: 3
      clk_cycles: 23
      fields:
        - field: opcode2
          value: "0x34"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting
          type: skip
          value: ")"
          order: 3
      definition: |
        // Increments the byte at memory location (IY + d).
        const addr = (registers.IY + d) & 0xFFFFn;
        const oldValue = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, (oldValue + 1n) & 0xFFn);
        registers.F = CAPI.ARCH.calculateFlags_INC(oldValue, registers.F);

    - name: dec
      template: FD
      nwords: 3
      clk_cycles: 23
      fields:
        - field: opcode2
          value: "0x35"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting
          type: skip
          value: ")"
          order: 3
      definition: |
        // Decrements the byte at memory location (IY + d).
        const addr = (registers.IY + d) & 0xFFFFn;
        const oldValue = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, (oldValue - 1n) & 0xFFn);
        registers.F = CAPI.ARCH.calculateFlags_DEC(oldValue, registers.F);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x70"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),b"
          order: 3
      definition: |
        // Stores B to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.B);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x71"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),c"
          order: 3
      definition: |
        // Stores C to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.C);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x72"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),d"
          order: 3
      definition: |
        // Stores D to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.D);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x73"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),d"
          order: 3
      definition: |
        // Stores D to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.D);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x74"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),h"
          order: 3
      definition: |
        // Stores H to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.H);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x75"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),l"
          order: 3
      definition: |
        // Stores L to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.L);

    - name: ld
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x77"
        - field: instructionFormatting
          type: skip
          value: "(iy+"
          order: 1
        - field: displacement
          type: imm-signed
          startbit: 23
          stopbit: 16
          order: 2
        - field: instructionFormatting2
          type: skip
          value: "),a"
          order: 3
      definition: |
        // Stores A to the memory location pointed to by IY plus d.
        const addr = (registers.IY + displacement) & 0xFFFFn;
        CAPI.MEM.write(addr, 1, registers.A);

    - name: add
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x86"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          prefix: "(iy+"
          suffix: ")"
          order: 2
      definition: |
        // Adds the value pointed to by IY plus d to A.
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        const oldValueA = registers.A;
        registers.A = (oldValueA + value) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_ADD(oldValueA, value);

    - name: sub
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0x96"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          prefix: "(iy+"
          suffix: ")"
          order: 2
      definition: |
        // Subtracts the value pointed to by IY plus d from A.
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        const oldValueA = registers.A;
        registers.A = (oldValueA - value) & 0xFFn;
        registers.F = CAPI.ARCH.calculateFlags_SUB(oldValueA, value);

    - name: and
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0xA6"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          prefix: "(iy+"
          suffix: ")"
          order: 2
      definition: |
        // Bitwise AND on A with the value pointed to by IY plus d.
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.A = registers.A & value;
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 1);

    - name: or
      template: FD
      nwords: 3
      clk_cycles: 19
      fields:
        - field: opcode2
          value: "0xB6"
        - field: instructionFormatting
          type: skip
          value: "a,"
          order: 1
        - field: d
          type: imm-signed
          startbit: 23
          stopbit: 16
          prefix: "(iy+"
          suffix: ")"
          order: 2
      definition: |
        // Bitwise OR on A with the value pointed to by IY plus d.
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        registers.A = registers.A | value;
        registers.F = CAPI.ARCH.calculateFlags_LOGICAL(registers.A, 0);

    - name: sbc
      template: ED
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x42"
        - field: instructionFormatting
          type: skip
          value: "hl, bc"
          order: 1
      definition: |
        // 1. Get 16-bit operands
        const hlValue = (registers.H << 8n) | registers.L;
        const bcValue = (registers.B << 8n) | registers.C;

        // 2. Perform the subtraction
        const carry = registers.F & CAPI.ARCH.C_FLAG;
        const result = (hlValue - bcValue - carry) & 0xFFFFn;

        // 3. Call the helper function to calculate all flags.
        //    We pass the original values to it.
        registers.F = CAPI.ARCH.calculateFlags_SBC16(hlValue, bcValue, registers.F);

        // 4. Update the destination register pair (HL) with the result.
        registers.H = (result >> 8n) & 0xFFn;
        registers.L = result & 0xFFn;

    - name: sbc
      template: ED
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x52"
        - field: instructionFormatting
          type: skip
          value: "hl, de"
          order: 1
      definition: |
        // 1. Get 16-bit operands
        const hlValue = (registers.H << 8n) | registers.L;
        const deValue = (registers.D << 8n) | registers.E;

        // 2. Perform the subtraction
        const carry = registers.F & CAPI.ARCH.C_FLAG;
        const result = (hlValue - deValue - carry) & 0xFFFFn;

        // 3. Call the helper function to calculate all flags.
        //    We pass the original values to it.
        registers.F = CAPI.ARCH.calculateFlags_SBC16(hlValue, deValue, registers.F);

        // 4. Update the destination register pair (HL) with the result.
        registers.H = (result >> 8n) & 0xFFn;
        registers.L = result & 0xFFn;

    - name: sbc
      template: ED
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x62"
        - field: instructionFormatting
          type: skip
          value: "hl, hl"
          order: 1
      definition: |
        // 1. Get 16-bit operands
        const hlValue = (registers.H << 8n) | registers.L;
        const hlValue2 = (registers.H << 8n) | registers.L;

        // 2. Perform the subtraction
        const carry = registers.F & CAPI.ARCH.C_FLAG;
        const result = (hlValue - hlValue2 - carry) & 0xFFFFn;

        // 3. Call the helper function to calculate all flags.
        //    We pass the original values to it.
        registers.F = CAPI.ARCH.calculateFlags_SBC16(hlValue, hlValue2, registers.F);

        // 4. Update the destination register pair (HL) with the result.
        registers.H = (result >> 8n) & 0xFFn;
        registers.L = result & 0xFFn;

    - name: sbc
      template: ED
      clk_cycles: 15
      fields:
        - field: opcode2
          value: "0x72"
        - field: instructionFormatting
          type: skip
          value: "hl, sp"
          order: 1
      definition: |
        // 1. Get 16-bit operands
        const hlValue = (registers.H << 8n) | registers.L;

        // 2. Perform the subtraction
        const carry = registers.F & CAPI.ARCH.C_FLAG;
        const result = (hlValue - registers.SP - carry) & 0xFFFFn;

        // 3. Call the helper function to calculate all flags.
        //    We pass the original values to it.
        registers.F = CAPI.ARCH.calculateFlags_SBC16(hlValue, registers.SP, registers.F);

        // 4. Update the destination register pair (HL) with the result.
        registers.H = (result >> 8n) & 0xFFn;
        registers.L = result & 0xFFn;

    # SET b, (IY+d)
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xC6"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "0,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x01n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xCE"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "1,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x02n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xD6"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "2,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x04n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xDE"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "3,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x08n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xE6"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "4,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x10n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xEE"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "5,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x20n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xF6"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "6,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x40n);
    - name: set
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xFE"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "7,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value | 0x80n);

    # RES b, (IY+d)
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x86"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "0,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x01n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x8E"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "1,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x02n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x96"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "2,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x04n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0x9E"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "3,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x08n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xA6"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "4,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x10n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xAE"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "5,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x20n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xB6"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "6,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x40n);
    - name: res
      template: FDCB
      clk_cycles: 23
      fields:
        - field: opcode3
          value: "0xBE"
        - field: d
          order: 3
          suffix: ")"
        - field: instructionFormatting
          type: skip
          value: "7,(iy+"
          order: 1
      definition: |
        const addr = (registers.IY + d) & 0xFFFFn;
        const value = CAPI.MEM.read(addr, 1);
        CAPI.MEM.write(addr, 1, value & ~0x80n);

interrupts:
  enabled: true
  check: |
    if (CAPI.ARCH.interruptPin) {
      // If we have an interrupts request (INT pin is asserted)

      // Save the current PC on the stack, so we know where to return
      // Z80 pushes high byte first, then low byte (little endian)
      let returnAddress = CAPI.REG.read('PC');
      let sp = CAPI.REG.read('SP');
      
      // Push high byte first
      sp = (sp - 1n) & 0xFFFFn;
      CAPI.MEM.write(sp, 1, (returnAddress >> 8n) & 0xFFn);
      
      // Then push low byte
      sp = (sp - 1n) & 0xFFFFn;
      CAPI.MEM.write(sp, 1, returnAddress & 0xFFn);
      
      // Update SP
      CAPI.REG.write(sp, 'SP');

      return InterruptType.External;
    } else {
      return null;
    }
  is_enabled: |
    // Check if interrupts are enabled (IFF1 flag)
    return !!(CAPI.REG.read('IFF1') & 1n);
  enable: |
    // Enable interrupts - set both IFF1 and IFF2
    CAPI.REG.write(1n, 'IFF1');
    CAPI.REG.write(1n, 'IFF2');
  disable: |
    // Disable interrupts - clear both IFF1 and IFF2  
    CAPI.REG.write(0n, 'IFF1');
    CAPI.REG.write(0n, 'IFF2');
  get_handler_addr: |
    if (CAPI.ARCH.interruptMode === 1) {
      // Mode 1: Always jump to RST 38h (0x0038)
      return 0x0038n;
    } else if (CAPI.ARCH.interruptMode === 0) {
      // Mode 0: Execute instruction from data bus (simplified as RST 38h)
      return 0x0038n;
    } else {
      return 0x0038n;
    }
  clear: |
    // Clear the simulated INT pin
    if (typeof CAPI.ARCH.interruptPin  !== 'undefined') {
      CAPI.ARCH.interruptPin = false;
    }
  create: |
    // Simulate asserting the INT pin (like external hardware would do)
    if (typeof CAPI.ARCH.interruptPin === 'undefined') {
      CAPI.ARCH.interruptPin = false;
    }

    switch (type) {
      case InterruptType.External:
        CAPI.ARCH.interruptPin = true; // Assert INT pin
        break;
      case InterruptType.Timer:
        CAPI.ARCH.interruptPin = true; // Timer also uses maskable interrupt
        break;
      default:
        CAPI.ARCH.interruptPin = true;
        break;
    }

timer:
  tick_cycles: 1
  advance: |
    CAPI.ARCH.timerCounter++;
  handler: |
    if (CAPI.ARCH.timerCounter >= 70000n) { // Sinclair ZX Spectrum ~50Hz (70000 cycles at 3.5MHz)
      CAPI.ARCH.timerCounter = 0n;
      CAPI.INTERRUPTS.make(CAPI.INTERRUPTS.Type.Timer);
    }
  is_enabled: |
    // Timer interrupts enabled if global interrupts are enabled
    return !!(CAPI.REG.read('IFF1') & 1n);
  enable: |
    return true;
  disable: |
    return false;
